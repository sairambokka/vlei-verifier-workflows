{
  "version": 3,
  "sources": ["../src/index.ts", "../src/exports.ts", "../src/ready.ts", "../src/keri/core/encrypter.ts", "../src/keri/core/kering.ts", "../src/keri/core/core.ts", "../src/keri/core/matter.ts", "../src/keri/core/base64.ts", "../src/keri/core/verfer.ts", "../src/keri/core/signer.ts", "../src/keri/core/cigar.ts", "../src/keri/core/indexer.ts", "../src/keri/core/siger.ts", "../src/keri/core/decrypter.ts", "../src/keri/core/salter.ts", "../src/keri/core/cipher.ts", "../src/keri/core/counter.ts", "../src/keri/core/seqner.ts", "../src/keri/core/diger.ts", "../src/keri/core/number.ts", "../src/keri/core/serder.ts", "../src/keri/core/prefixer.ts", "../src/keri/core/saider.ts", "../src/keri/core/utils.ts", "../src/keri/core/manager.ts", "../src/keri/core/tholder.ts", "../src/keri/core/eventing.ts", "../src/keri/app/habery.ts", "../src/keri/app/controller.ts", "../src/keri/core/httping.ts", "../src/keri/app/aiding.ts", "../src/keri/end/ending.ts", "../src/keri/core/authing.ts", "../src/keri/core/keeping.ts", "../src/keri/app/contacting.ts", "../src/keri/app/coring.ts", "../src/keri/core/vdring.ts", "../src/keri/app/credentialing.ts", "../src/keri/app/delegating.ts", "../src/keri/app/escrowing.ts", "../src/keri/core/bexter.ts", "../src/keri/core/pather.ts", "../src/keri/app/exchanging.ts", "../src/keri/app/grouping.ts", "../src/keri/app/notifying.ts", "../src/keri/app/clienting.ts"],
  "sourcesContent": ["import * as exp from './exports';\nexport * from './exports';\nexport default exp;\n", "export * from './ready';\n\nexport * from './keri/app/habery';\nexport * from './keri/app/controller';\n\nexport * from './keri/app/aiding';\nexport * from './keri/app/clienting';\nexport * from './keri/app/contacting';\nexport * from './keri/app/coring';\nexport * from './keri/app/credentialing';\nexport * from './keri/app/escrowing';\nexport * from './keri/app/exchanging';\nexport * from './keri/app/grouping';\nexport * from './keri/app/notifying';\n\nexport * from './keri/core/authing';\nexport * from './keri/core/cigar';\nexport * from './keri/core/cipher';\nexport * from './keri/core/core';\nexport * from './keri/core/counter';\nexport * from './keri/core/decrypter';\nexport * from './keri/core/diger';\nexport * from './keri/core/encrypter';\nexport * from './keri/core/eventing';\nexport * from './keri/core/httping';\nexport * from './keri/core/indexer';\nexport * from './keri/core/keeping';\nexport * from './keri/core/kering';\nexport * from './keri/core/manager';\nexport * from './keri/core/matter';\nexport * from './keri/core/number';\nexport * from './keri/core/prefixer';\nexport * from './keri/core/saider';\nexport * from './keri/core/salter';\nexport * from './keri/core/seqner';\nexport * from './keri/core/serder';\nexport * from './keri/core/siger';\nexport * from './keri/core/signer';\nexport * from './keri/core/tholder';\nexport * from './keri/core/utils';\nexport * from './keri/core/verfer';\nexport * from './keri/core/state';\n\nexport * from './keri/end/ending';\n", "import _sodium from 'libsodium-wrappers-sumo';\n\nexport const ready: () => Promise<void> = async () => {\n    await _sodium.ready;\n};\n", "import libsodium from 'libsodium-wrappers-sumo';\n\nimport { Matter, MatterArgs, MtrDex } from './matter';\nimport { Verfer } from './verfer';\nimport { Signer } from './signer';\nimport { Cipher } from './cipher';\nimport { arrayEquals } from './utils';\n\nexport class Encrypter extends Matter {\n    private _encrypt: any;\n    constructor(\n        { raw, code = MtrDex.X25519, qb64, qb64b, qb2 }: MatterArgs,\n        verkey: Uint8Array | null = null\n    ) {\n        if (raw == undefined && verkey != null) {\n            const verfer = new Verfer({ qb64b: verkey });\n            if (\n                !Array.from([MtrDex.Ed25519N, MtrDex.Ed25519]).includes(\n                    verfer.code\n                )\n            ) {\n                throw new Error(\n                    `Unsupported verkey derivation code = ${verfer.code}.`\n                );\n            }\n            raw = libsodium.crypto_sign_ed25519_pk_to_curve25519(verfer.raw);\n        }\n\n        super({ raw, code, qb64, qb64b, qb2 });\n\n        if (this.code == MtrDex.X25519) {\n            this._encrypt = this._x25519;\n        } else {\n            throw new Error(`Unsupported encrypter code = ${this.code}.`);\n        }\n    }\n\n    verifySeed(seed: Uint8Array) {\n        const signer = new Signer({ qb64b: seed });\n        const keypair = libsodium.crypto_sign_seed_keypair(signer.raw);\n        const pubkey = libsodium.crypto_sign_ed25519_pk_to_curve25519(\n            keypair.publicKey\n        );\n        return arrayEquals(pubkey, this.raw);\n    }\n\n    encrypt(ser: Uint8Array | null = null, matter: Matter | null = null) {\n        if (ser == null && matter == null) {\n            throw new Error('Neither ser nor matter are provided.');\n        }\n\n        if (ser != null) {\n            matter = new Matter({ qb64b: ser });\n        }\n\n        let code;\n        if (matter!.code == MtrDex.Salt_128) {\n            code = MtrDex.X25519_Cipher_Salt;\n        } else {\n            code = MtrDex.X25519_Cipher_Seed;\n        }\n\n        return this._encrypt(matter!.qb64, this.raw, code);\n    }\n\n    _x25519(ser: Uint8Array, pubkey: Uint8Array, code: string) {\n        const raw = libsodium.crypto_box_seal(ser, pubkey);\n        return new Cipher({ raw: raw, code: code });\n    }\n}\n", "export class EmptyMaterialError {\n    private readonly _err: Error;\n    constructor(err: string) {\n        this._err = new Error(err);\n    }\n\n    get err() {\n        return this._err;\n    }\n}\n", "export enum Serials {\n    JSON = 'JSON',\n}\n\nexport enum Ident {\n    KERI = 'KERI',\n    ACDC = 'ACDC',\n}\n\nexport class Version {\n    public major: number;\n    public minor: number;\n\n    constructor(major: number = 1, minor: number = 0) {\n        this.major = major;\n        this.minor = minor;\n    }\n}\n\nexport const Versionage = new Version();\n\nexport const Ilks = {\n    icp: 'icp',\n    rot: 'rot',\n    ixn: 'ixn',\n    dip: 'dip',\n    drt: 'drt',\n    rct: 'rct',\n    vrc: 'vrc',\n    rpy: 'rpy',\n    exn: 'exn',\n    vcp: 'vcp',\n    iss: 'iss',\n    rev: 'rev',\n};\n\nexport const IcpLabels = [\n    'v',\n    'i',\n    's',\n    't',\n    'kt',\n    'k',\n    'n',\n    'bt',\n    'b',\n    'c',\n    'a',\n];\n\nexport const DipLabels = [\n    'v',\n    'i',\n    's',\n    't',\n    'kt',\n    'k',\n    'n',\n    'bt',\n    'b',\n    'c',\n    'a',\n    'di',\n];\n\nexport const RotLabels = [\n    'v',\n    'i',\n    's',\n    't',\n    'p',\n    'kt',\n    'k',\n    'n',\n    'bt',\n    'br',\n    'ba',\n    'a',\n];\nexport const DrtLabels = [\n    'v',\n    'i',\n    's',\n    't',\n    'p',\n    'kt',\n    'k',\n    'n',\n    'bt',\n    'br',\n    'ba',\n    'a',\n];\nexport const IxnLabels = ['v', 'i', 's', 't', 'p', 'a'];\n\nexport const KsnLabels = [\n    'v',\n    'i',\n    's',\n    't',\n    'p',\n    'd',\n    'f',\n    'dt',\n    'et',\n    'kt',\n    'k',\n    'n',\n    'bt',\n    'b',\n    'c',\n    'ee',\n    'di',\n    'r',\n];\n\nexport const RpyLabels = ['v', 't', 'd', 'dt', 'r', 'a'];\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nexport const VERFULLSIZE = 17;\nexport const MINSNIFFSIZE = 12 + VERFULLSIZE;\nexport const MINSIGSIZE = 4;\n\n// const version_pattern = 'KERI(?P<major>[0-9a-f])(?P<minor>[0-9a-f])\n// (?P<kind>[A-Z]{4})(?P<size>[0-9a-f]{6})'\n// const version_pattern1 = `KERI\\(\\?P<major>\\[0\\-9a\\-f\\]\\)\\(\\?P<minor>\\[0\\-9a\\-f\\]\\)\\\n// (\\?P<kind>\\[A\\-Z\\]\\{4\\}\\)\\(\\?P<size>\\[0\\-9a\\-f\\]\\{6\\}\\)_`\n\nexport const VEREX = '(KERI|ACDC)([0-9a-f])([0-9a-f])([A-Z]{4})([0-9a-f]{6})_';\n\nexport interface Dict<TValue> {\n    [id: string]: TValue;\n}\n\n// Regex pattern matching\n\n/**\n * @description This function is use to deversify the version\n * Here we will use regex to  to validate and extract serialization kind,size and version\n * @param {string} versionString   version string\n * @return {Object}  contaning prototol (KERI or ACDC), kind of serialization like cbor,json,mgpk\n *                    version = version of object ,size = raw size integer\n */\nexport function deversify(\n    versionString: string\n): [Ident, Serials, Version, string] {\n    let kind;\n    let size;\n    let proto;\n    const version = Versionage;\n\n    // we need to identify how to match the buffers pattern ,like we do regex matching for strings\n    const re = new RegExp(VEREX);\n\n    const match = re.exec(versionString);\n\n    if (match) {\n        [proto, version.major, version.minor, kind, size] = [\n            match[1],\n            +match[2],\n            +match[3],\n            match[4],\n            match[5],\n        ];\n        if (!Object.values(Serials).includes(kind as Serials)) {\n            throw new Error(`Invalid serialization kind = ${kind}`);\n        }\n        if (!Object.values(Ident).includes(proto as Ident)) {\n            throw new Error(`Invalid serialization kind = ${kind}`);\n        }\n\n        const ta = kind as keyof typeof Serials;\n        kind = Serials[ta];\n        const pa = proto as keyof typeof Ident;\n        proto = Ident[pa];\n\n        return [proto, kind, version, size];\n    }\n    throw new Error(`Invalid version string = ${versionString}`);\n}\n\nexport function versify(\n    ident: Ident = Ident.KERI,\n    version?: Version,\n    kind: Serials = Serials.JSON,\n    size: number = 0\n) {\n    version = version == undefined ? Versionage : version;\n\n    return `${ident}${version.major.toString(\n        16\n    )}${version.minor.toString()}${kind}${size.toString(16).padStart(6, '0')}_`;\n}\n\nexport const B64ChrByIdx = new Map<number, string>([\n    [0, 'A'],\n    [1, 'B'],\n    [2, 'C'],\n    [3, 'D'],\n    [4, 'E'],\n    [5, 'F'],\n    [6, 'G'],\n    [7, 'H'],\n    [8, 'I'],\n    [9, 'J'],\n    [10, 'K'],\n    [11, 'L'],\n    [12, 'M'],\n    [13, 'N'],\n    [14, 'O'],\n    [15, 'P'],\n    [16, 'Q'],\n    [17, 'R'],\n    [18, 'S'],\n    [19, 'T'],\n    [20, 'U'],\n    [21, 'V'],\n    [22, 'W'],\n    [23, 'X'],\n    [24, 'Y'],\n    [25, 'Z'],\n    [26, 'a'],\n    [27, 'b'],\n    [28, 'c'],\n    [29, 'd'],\n    [30, 'e'],\n    [31, 'f'],\n    [32, 'g'],\n    [33, 'h'],\n    [34, 'i'],\n    [35, 'j'],\n    [36, 'k'],\n    [37, 'l'],\n    [38, 'm'],\n    [39, 'n'],\n    [40, 'o'],\n    [41, 'p'],\n    [42, 'q'],\n    [43, 'r'],\n    [44, 's'],\n    [45, 't'],\n    [46, 'u'],\n    [47, 'v'],\n    [48, 'w'],\n    [49, 'x'],\n    [50, 'y'],\n    [51, 'z'],\n    [52, '0'],\n    [53, '1'],\n    [54, '2'],\n    [55, '3'],\n    [56, '4'],\n    [57, '5'],\n    [58, '6'],\n    [59, '7'],\n    [60, '8'],\n    [61, '9'],\n    [62, '-'],\n    [63, '_'],\n]);\n\nexport const B64IdxByChr = new Map<string, number>(\n    Array.from(B64ChrByIdx, (entry) => [entry[1], entry[0]])\n);\n\nexport function intToB64(i: number, l = 1): string {\n    let out = '';\n    while (l != 0) {\n        out = B64ChrByIdx.get(i % 64) + out;\n        i = Math.floor(i / 64);\n        if (i == 0) {\n            break;\n        }\n    }\n\n    const x = l - out.length;\n    for (let i = 0; i < x; i++) {\n        out = 'A' + out;\n    }\n\n    return out;\n}\n\nexport function intToB64b(n: number, l: number = 1): Uint8Array {\n    const s = intToB64(n, l);\n    return b(s);\n}\n\nexport function b64ToInt(s: string): number {\n    if (s.length == 0) {\n        throw new Error('Empty string, conversion undefined.');\n    }\n\n    let i = 0;\n    const rev = s.split('').reverse();\n    rev.forEach((c: string, e: number) => {\n        i |= B64IdxByChr.get(c)! << (e * 6);\n    });\n\n    return i;\n}\n\nexport function b(s?: string): Uint8Array {\n    return encoder.encode(s);\n}\n\nexport function d(u?: Uint8Array): string {\n    return decoder.decode(u);\n}\n\nexport function concat(one: Uint8Array, two: Uint8Array): Uint8Array {\n    const out = new Uint8Array(one.length + two.length);\n    out.set(one);\n    out.set(two, one.length);\n    return out;\n}\n\nexport function readInt(array: Uint8Array) {\n    let value = 0;\n    for (let i = 0; i < array.length; i++) {\n        value = value * 256 + array[i];\n    }\n    return value;\n}\n", "import { EmptyMaterialError } from './kering';\n\nimport { intToB64, readInt } from './core';\nimport { b, d } from './core';\nimport { Buffer } from 'buffer';\nimport { decodeBase64Url, encodeBase64Url } from './base64';\n\nexport class Codex {\n    has(prop: string): boolean {\n        const m = new Map(\n            Array.from(Object.entries(this), (v) => [v[1], v[0]])\n        );\n        return m.has(prop);\n    }\n}\n\nexport class MatterCodex extends Codex {\n    Ed25519_Seed: string = 'A'; // Ed25519 256 bit random seed for private key\n    Ed25519N: string = 'B'; // Ed25519 verification key non-transferable, basic derivation.\n    X25519: string = 'C'; // X25519 public encryption key, converted from Ed25519 or Ed25519N.\n    Ed25519: string = 'D'; // Ed25519 verification key basic derivation\n    Blake3_256: string = 'E'; // Blake3 256 bit digest self-addressing derivation.\n    SHA3_256: string = 'H'; // SHA3 256 bit digest self-addressing derivation.\n    SHA2_256: string = 'I'; // SHA2 256 bit digest self-addressing derivation.\n    ECDSA_256k1_Seed: string = 'J'; // ECDSA secp256k1 256 bit random Seed for private key\n    X25519_Private: string = 'O'; // X25519 private decryption key converted from Ed25519\n    X25519_Cipher_Seed: string = 'P'; // X25519 124 char b64 Cipher of 44 char qb64 Seed\n    ECDSA_256r1_Seed: string = 'Q'; // ECDSA secp256r1 256 bit random Seed for private key\n    Salt_128: string = '0A'; // 128 bit random salt or 128 bit number (see Huge)\n    Ed25519_Sig: string = '0B'; // Ed25519 signature.\n    ECDSA_256k1_Sig: string = '0C'; // ECDSA secp256k1 signature.\n    ECDSA_256r1_Sig: string = '0I'; // ECDSA secp256r1 signature.\n    StrB64_L0: string = '4A'; // String Base64 Only Lead Size 0\n    StrB64_L1: string = '5A'; // String Base64 Only Lead Size 1\n    StrB64_L2: string = '6A'; // String Base64 Only Lead Size 2\n    ECDSA_256k1N: string = '1AAA'; // ECDSA secp256k1 verification key non-transferable, basic derivation.\n    ECDSA_256k1: string = '1AAB'; // ECDSA public verification or encryption key, basic derivation\n    X25519_Cipher_Salt: string = '1AAH'; // X25519 100 char b64 Cipher of 24 char qb64 Salt\n    ECDSA_256r1N: string = '1AAI'; // ECDSA secp256r1 verification key non-transferable, basic derivation.\n    ECDSA_256r1: string = '1AAJ'; // ECDSA secp256r1 verification or encryption key, basic derivation\n    StrB64_Big_L0: string = '7AAA'; // String Base64 Only Big Lead Size 0\n    StrB64_Big_L1: string = '8AAA'; // String Base64 Only Big Lead Size 1\n    StrB64_Big_L2: string = '9AAA'; // String Base64 Only Big Lead Size 2\n}\n\nexport const MtrDex = new MatterCodex();\n\nexport class NonTransCodex extends Codex {\n    Ed25519N: string = 'B'; // Ed25519 verification key non-transferable, basic derivation.\n    ECDSA_256k1N: string = '1AAA'; // ECDSA secp256k1 verification key non-transferable, basic derivation.\n    Ed448N: string = '1AAC'; // Ed448 non-transferable prefix public signing verification key. Basic derivation.\n    ECDSA_256r1N: string = '1AAI'; // ECDSA secp256r1 verification key non-transferable, basic derivation.\n}\n\nexport const NonTransDex = new NonTransCodex();\n\nexport class DigiCodex extends Codex {\n    Blake3_256: string = 'E'; // Blake3 256 bit digest self-addressing derivation.\n    Blake2b_256: string = 'F'; // Blake2b 256 bit digest self-addressing derivation.\n    Blake2s_256: string = 'G'; // Blake2s 256 bit digest self-addressing derivation.\n    SHA3_256: string = 'H'; // SHA3 256 bit digest self-addressing derivation.\n    SHA2_256: string = 'I'; // SHA2 256 bit digest self-addressing derivation.\n    Blake3_512: string = '0D'; // Blake3 512 bit digest self-addressing derivation.\n    Blake2b_512: string = '0E'; // Blake2b 512 bit digest self-addressing derivation.\n    SHA3_512: string = '0F'; // SHA3 512 bit digest self-addressing derivation.\n    SHA2_512: string = '0G'; // SHA2 512 bit digest self-addressing derivation.\n}\n\nexport const DigiDex = new DigiCodex();\n\nexport class NumCodex extends Codex {\n    Short: string = 'M'; // Short 2 byte b2 number\n    Long: string = '0H'; // Long 4 byte b2 number\n    Big: string = 'N'; // Big 8 byte b2 number\n    Huge: string = '0A'; // Huge 16 byte b2 number (same as Salt_128)\n}\n\nexport const NumDex = new NumCodex();\n\nexport class BexCodex extends Codex {\n    StrB64_L0: string = '4A'; // String Base64 Only Leader Size 0\n    StrB64_L1: string = '5A'; // String Base64 Only Leader Size 1\n    StrB64_L2: string = '6A'; // String Base64 Only Leader Size 2\n    StrB64_Big_L0: string = '7AAA'; // String Base64 Only Big Leader Size 0\n    StrB64_Big_L1: string = '8AAA'; // String Base64 Only Big Leader Size 1\n    StrB64_Big_L2: string = '9AAA'; // String Base64 Only Big Leader Size 2\n}\n\nexport const BexDex = new BexCodex();\n\nclass SmallVarRawSizeCodex extends Codex {\n    Lead0: string = '4'; // First Selector Character for all ls == 0 codes\n    Lead1: string = '5'; // First Selector Character for all ls == 1 codes\n    Lead2: string = '6'; // First Selector Character for all ls == 2 codes\n}\n\nexport const SmallVrzDex = new SmallVarRawSizeCodex();\n\nclass LargeVarRawSizeCodex extends Codex {\n    Lead0_Big: string = '7'; // First Selector Character for all ls == 0 codes\n    Lead1_Big: string = '8'; // First Selector Character for all ls == 1 codes\n    Lead2_Big: string = '9'; // First Selector Character for all ls == 2 codes\n}\n\nexport const LargeVrzDex = new LargeVarRawSizeCodex();\n\nexport class Sizage {\n    public hs: number;\n    public ss: number;\n    public ls?: number;\n    public fs?: number;\n\n    constructor(hs: number, ss: number, fs?: number, ls?: number) {\n        this.hs = hs;\n        this.ss = ss;\n        this.fs = fs;\n        this.ls = ls!;\n    }\n}\n\nexport interface MatterArgs {\n    raw?: Uint8Array | undefined;\n    code?: string;\n    qb64b?: Uint8Array | undefined;\n    qb64?: string;\n    qb2?: Uint8Array | undefined;\n    rize?: number;\n}\n\nexport class Matter {\n    static Sizes = new Map(\n        Object.entries({\n            A: new Sizage(1, 0, 44, 0),\n            B: new Sizage(1, 0, 44, 0),\n            C: new Sizage(1, 0, 44, 0),\n            D: new Sizage(1, 0, 44, 0),\n            E: new Sizage(1, 0, 44, 0),\n            F: new Sizage(1, 0, 44, 0),\n            G: new Sizage(1, 0, 44, 0),\n            H: new Sizage(1, 0, 44, 0),\n            I: new Sizage(1, 0, 44, 0),\n            J: new Sizage(1, 0, 44, 0),\n            K: new Sizage(1, 0, 76, 0),\n            L: new Sizage(1, 0, 76, 0),\n            M: new Sizage(1, 0, 4, 0),\n            N: new Sizage(1, 0, 12, 0),\n            O: new Sizage(1, 0, 44, 0),\n            P: new Sizage(1, 0, 124, 0),\n            Q: new Sizage(1, 0, 44, 0),\n            '0A': new Sizage(2, 0, 24, 0),\n            '0B': new Sizage(2, 0, 88, 0),\n            '0C': new Sizage(2, 0, 88, 0),\n            '0D': new Sizage(2, 0, 88, 0),\n            '0E': new Sizage(2, 0, 88, 0),\n            '0F': new Sizage(2, 0, 88, 0),\n            '0G': new Sizage(2, 0, 88, 0),\n            '0H': new Sizage(2, 0, 8, 0),\n            '0I': new Sizage(2, 0, 88, 0),\n            '1AAA': new Sizage(4, 0, 48, 0),\n            '1AAB': new Sizage(4, 0, 48, 0),\n            '1AAC': new Sizage(4, 0, 80, 0),\n            '1AAD': new Sizage(4, 0, 80, 0),\n            '1AAE': new Sizage(4, 0, 56, 0),\n            '1AAF': new Sizage(4, 0, 8, 0),\n            '1AAG': new Sizage(4, 0, 36, 0),\n            '1AAH': new Sizage(4, 0, 100, 0),\n            '1AAI': new Sizage(4, 0, 48, 0),\n            '1AAJ': new Sizage(4, 0, 48, 0),\n            '2AAA': new Sizage(4, 0, 8, 1),\n            '3AAA': new Sizage(4, 0, 8, 2),\n            '4A': new Sizage(2, 2, undefined, 0),\n            '5A': new Sizage(2, 2, undefined, 1),\n            '6A': new Sizage(2, 2, undefined, 2),\n            '7AAA': new Sizage(4, 4, undefined, 0),\n            '8AAA': new Sizage(4, 4, undefined, 1),\n            '9AAA': new Sizage(4, 4, undefined, 2),\n            '4B': new Sizage(2, 2, undefined, 0),\n            '5B': new Sizage(2, 2, undefined, 1),\n            '6B': new Sizage(2, 2, undefined, 2),\n            '7AAB': new Sizage(4, 4, undefined, 0),\n            '8AAB': new Sizage(4, 4, undefined, 1),\n            '9AAB': new Sizage(4, 4, undefined, 2),\n        })\n    );\n\n    static Hards = new Map<string, number>([\n        ['A', 1],\n        ['B', 1],\n        ['C', 1],\n        ['D', 1],\n        ['E', 1],\n        ['F', 1],\n        ['G', 1],\n        ['H', 1],\n        ['I', 1],\n        ['J', 1],\n        ['K', 1],\n        ['L', 1],\n        ['M', 1],\n        ['N', 1],\n        ['O', 1],\n        ['P', 1],\n        ['Q', 1],\n        ['R', 1],\n        ['S', 1],\n        ['T', 1],\n        ['U', 1],\n        ['V', 1],\n        ['W', 1],\n        ['X', 1],\n        ['Y', 1],\n        ['Z', 1],\n        ['a', 1],\n        ['b', 1],\n        ['c', 1],\n        ['d', 1],\n        ['e', 1],\n        ['f', 1],\n        ['g', 1],\n        ['h', 1],\n        ['i', 1],\n        ['j', 1],\n        ['k', 1],\n        ['l', 1],\n        ['m', 1],\n        ['n', 1],\n        ['o', 1],\n        ['p', 1],\n        ['q', 1],\n        ['r', 1],\n        ['s', 1],\n        ['t', 1],\n        ['u', 1],\n        ['v', 1],\n        ['w', 1],\n        ['x', 1],\n        ['y', 1],\n        ['z', 1],\n        ['0', 2],\n        ['1', 4],\n        ['2', 4],\n        ['3', 4],\n        ['4', 2],\n        ['5', 2],\n        ['6', 2],\n        ['7', 4],\n        ['8', 4],\n        ['9', 4],\n    ]);\n\n    private _code: string = '';\n    private _size: number = -1;\n    private _raw: Uint8Array = new Uint8Array(0);\n\n    constructor({\n        raw,\n        code = MtrDex.Ed25519N,\n        qb64b,\n        qb64,\n        qb2,\n        rize,\n    }: MatterArgs) {\n        let size = -1;\n        if (raw != undefined) {\n            if (code.length == 0) {\n                throw new Error(\n                    'Improper initialization need either (raw and code) or qb64b or qb64 or qb2.'\n                );\n            }\n\n            if (SmallVrzDex.has(code[0]) || LargeVrzDex.has(code[0])) {\n                if (rize !== undefined) {\n                    if (rize < 0)\n                        throw new Error(\n                            `missing var raw size for code=${code}`\n                        );\n                } else {\n                    rize = raw.length;\n                }\n\n                const ls = (3 - (rize % 3)) % 3; // calc actual lead (pad) size\n                size = Math.floor((rize + ls) / 3); // calculate value of size in triplets\n                if (SmallVrzDex.has(code[0])) {\n                    if (size <= 64 ** 2 - 1) {\n                        const hs = 2;\n                        const s = Object.values(SmallVrzDex)[ls];\n                        code = `${s}${code.substring(1, hs)}`;\n                    } else if (size <= 64 ** 4 - 1) {\n                        const hs = 4;\n                        const s = Object.values(LargeVrzDex)[ls];\n                        code = `${s}${'AAAA'.substring(0, hs - 2)}${code[1]}`;\n                    } else {\n                        throw new Error(\n                            `Unsupported raw size for code=${code}`\n                        );\n                    }\n                } else {\n                    if (size <= 64 ** 4 - 1) {\n                        const hs = 4;\n                        const s = Object.values(LargeVrzDex)[ls];\n                        code = `${s}${code.substring(1, hs)}`;\n                    } else {\n                        throw new Error(\n                            `Unsupported raw size for code=${code}`\n                        );\n                    }\n                }\n            } else {\n                const sizage = Matter.Sizes.get(code);\n                if (sizage!.fs == -1) {\n                    // invalid\n                    throw new Error(`Unsupported variable size code=${code}`);\n                }\n\n                rize = Matter._rawSize(code);\n            }\n            raw = raw.slice(0, rize); // copy only exact size from raw stream\n            if (raw.length != rize) {\n                // forbids shorter\n                throw new Error(\n                    `Not enougth raw bytes for code=${code} expected ${rize} got ${raw.length}.`\n                );\n            }\n\n            this._code = code; // hard value part of code\n            this._size = size; // soft value part of code in int\n            this._raw = raw; // crypto ops require bytes not bytearray\n        } else if (qb64 !== undefined) {\n            this._exfil(qb64);\n        } else if (qb64b !== undefined) {\n            const qb64 = d(qb64b);\n            this._exfil(qb64);\n        } else if (qb2 !== undefined) {\n            this._bexfil(qb2);\n        } else {\n            throw new EmptyMaterialError('EmptyMaterialError');\n        }\n    }\n\n    get code(): string {\n        return this._code;\n    }\n\n    get size() {\n        return this._size;\n    }\n\n    get raw(): Uint8Array {\n        return this._raw;\n    }\n\n    get qb64() {\n        return this._infil();\n    }\n\n    get qb64b() {\n        return b(this.qb64);\n    }\n\n    get transferable(): boolean {\n        return !NonTransDex.has(this.code);\n    }\n\n    get digestive(): boolean {\n        return DigiDex.has(this.code);\n    }\n\n    static _rawSize(code: string) {\n        const sizage = this.Sizes.get(code); // get sizes\n        const cs = sizage!.hs + sizage!.ss; // both hard + soft code size\n        if (sizage!.fs === -1) {\n            throw Error(`Non-fixed raw size code ${code}.`);\n        }\n\n        return Math.floor(((sizage!.fs! - cs) * 3) / 4) - sizage!.ls!;\n    }\n\n    static _leadSize(code: string) {\n        const sizage = this.Sizes.get(code);\n        return sizage!.ls;\n    }\n\n    get both() {\n        const sizage = Matter.Sizes.get(this.code);\n        return `${this.code}${intToB64(this.size, sizage!.ss)}`;\n    }\n\n    private _infil() {\n        const code = this.code;\n        const size = this.size;\n        const raw = this.raw;\n\n        const ps = (3 - (raw.length % 3)) % 3; // pad size chars or lead size bytes\n        const sizage = Matter.Sizes.get(code);\n\n        if (sizage!.fs === undefined) {\n            // Variable size code, NOT SUPPORTED\n            const cs = sizage!.hs + sizage!.ss;\n            if (cs % 4) {\n                throw new Error(\n                    `Whole code size not multiple of 4 for variable length material. cs=${cs}`\n                );\n            }\n            if (size < 0 || size > 64 ** sizage!.ss - 1) {\n                throw new Error(`Invalid size=${size} for code=${code}.`);\n            }\n\n            const both = `${code}${intToB64(size, sizage!.ss)}`;\n            if (both.length % 4 !== ps - sizage!.ls!) {\n                throw new Error(\n                    `Invalid code=${both} for converted raw pad size=${ps}.`\n                );\n            }\n\n            const bytes = new Uint8Array(sizage!.ls! + raw.length);\n            for (let i = 0; i < sizage!.ls!; i++) {\n                bytes[i] = 0;\n            }\n            for (let i = 0; i < raw.length; i++) {\n                const odx = i + ps;\n                bytes[odx] = raw[i];\n            }\n\n            return both + encodeBase64Url(Buffer.from(bytes));\n        } else {\n            const both = code;\n            const cs = both.length;\n            if (cs % 4 != ps - sizage!.ls!) {\n                // adjusted pad given lead bytes\n                throw new Error(\n                    `Invalid code=${both} for converted raw pad size=${ps}, ${raw.length}.`\n                );\n            }\n            // prepad, convert, and replace upfront\n            // when fixed and ls != 0 then cs % 4 is zero and ps==ls\n            // otherwise  fixed and ls == 0 then cs % 4 == ps\n            const bytes = new Uint8Array(ps + raw.length);\n            for (let i = 0; i < ps; i++) {\n                bytes[i] = 0;\n            }\n            for (let i = 0; i < raw.length; i++) {\n                const odx = i + ps;\n                bytes[odx] = raw[i];\n            }\n\n            return both + encodeBase64Url(Buffer.from(bytes)).slice(cs % 4);\n        }\n    }\n\n    private _exfil(qb64: string) {\n        if (qb64.length == 0) {\n            throw new Error('Empty Material');\n        }\n\n        const first = qb64[0];\n        if (!Array.from(Matter.Hards.keys()).includes(first)) {\n            throw new Error(`Unexpected code ${first}`);\n        }\n\n        const hs = Matter.Hards.get(first);\n        if (qb64.length < hs!) {\n            throw new Error(`Shortage Error`);\n        }\n\n        const hard = qb64.slice(0, hs);\n        if (!Array.from(Matter.Sizes.keys()).includes(hard)) {\n            throw new Error(`Unsupported code ${hard}`);\n        }\n\n        const sizage = Matter.Sizes.get(hard);\n        const cs = sizage!.hs + sizage!.ss;\n        let size = -1;\n        if (sizage!.fs == -1) {\n            // Variable size code, Not supported\n            throw new Error('Variable size codes not supported yet');\n        } else {\n            size = sizage!.fs!;\n        }\n\n        if (qb64.length < sizage!.fs!) {\n            throw new Error(`Need ${sizage!.fs! - qb64.length} more chars.`);\n        }\n\n        qb64 = qb64.slice(0, sizage!.fs);\n        const ps = cs % 4;\n        const pbs = 2 * (ps == 0 ? sizage!.ls! : ps);\n        let raw;\n        if (ps != 0) {\n            const base = new Array(ps + 1).join('A') + qb64.slice(cs);\n            const paw = decodeBase64Url(base); // decode base to leave prepadded raw\n            const pi = readInt(paw.subarray(0, ps)); // prepad as int\n            if (pi & (2 ** pbs - 1)) {\n                // masked pad bits non-zero\n                throw new Error(\n                    `Non zeroed prepad bits = {pi & (2 ** pbs - 1 ):<06b} in {qb64b[cs:cs+1]}.`\n                );\n            }\n            raw = paw.subarray(ps); // strip off ps prepad paw bytes\n        } else {\n            const base = qb64.slice(cs);\n            const paw = decodeBase64Url(base);\n            const li = readInt(paw.subarray(0, sizage!.ls));\n            if (li != 0) {\n                if (li == 1) {\n                    throw new Error(`Non zeroed lead byte = 0x{li:02x}.`);\n                } else {\n                    throw new Error(`Non zeroed lead bytes = 0x{li:04x}`);\n                }\n            }\n            raw = paw.subarray(sizage!.ls);\n        }\n\n        this._code = hard; // hard only\n        this._size = size;\n        this._raw = Uint8Array.from(raw); // ensure bytes so immutable and for crypto ops\n    }\n\n    private _bexfil(qb2: Uint8Array) {\n        throw new Error(`qb2 not yet supported: ${qb2}`);\n    }\n}\n", "import { Buffer } from 'buffer';\n// base64url is supported by node Buffer, but not in buffer package for browser compatibility\n// https://github.com/feross/buffer/issues/309\n\n// Instead of using a node.js-only module and forcing us to polyfill the Buffer global,\n// we insert code from https://gitlab.com/seangenabe/safe-base64 here\n\nexport function encodeBase64Url(buffer: Buffer) {\n    if (!Buffer.isBuffer(buffer)) {\n        throw new TypeError('`buffer` must be a buffer.');\n    }\n    return buffer\n        .toString('base64')\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=+/, '');\n}\n\nexport function decodeBase64Url(input: string) {\n    if (!(typeof input === 'string')) {\n        throw new TypeError('`input` must be a string.');\n    }\n\n    const n = input.length % 4;\n    const padded = input + '='.repeat(n > 0 ? 4 - n : n);\n    const base64String = padded.replace(/-/g, '+').replace(/_/g, '/');\n    return Buffer.from(base64String, 'base64');\n}\n", "export {};\nimport libsodium from 'libsodium-wrappers-sumo';\nimport { Matter, MatterArgs, MtrDex } from './matter';\nimport secp256r1 from 'ecdsa-secp256r1';\n\n/**\n * @description  Verfer :sublclass of Matter,helps to verify signature of serialization\n *  using .raw as verifier key and .code as signature cypher suite\n */\nexport class Verfer extends Matter {\n    private readonly _verify: (sig: any, ser: any, key: any) => boolean;\n    constructor({ raw, code, qb64, qb64b, qb2 }: MatterArgs) {\n        super({ raw, code, qb64, qb64b, qb2 });\n\n        if (Array.from([MtrDex.Ed25519N, MtrDex.Ed25519]).includes(this.code)) {\n            this._verify = this._ed25519;\n        } else if (\n            Array.from([MtrDex.ECDSA_256r1N, MtrDex.ECDSA_256r1]).includes(\n                this.code\n            )\n        ) {\n            this._verify = this._secp256r1;\n        } else {\n            throw new Error(`Unsupported code = ${this.code} for verifier.`);\n        }\n    }\n\n    verify(sig: any, ser: any) {\n        return this._verify(sig, ser, this.raw);\n    }\n\n    _ed25519(sig: any, ser: any, key: any) {\n        try {\n            return libsodium.crypto_sign_verify_detached(sig, ser, key);\n        } catch (error) {\n            throw new Error(error as string);\n        }\n    }\n    _secp256r1(sig: any, ser: any, key: any) {\n        try {\n            const publicKey = secp256r1.fromCompressedPublicKey(key);\n            return publicKey.verify(ser, sig);\n        } catch (error) {\n            throw new Error(error as string);\n        }\n    }\n}\n", "import { EmptyMaterialError } from './kering';\n\nexport {};\nimport libsodium from 'libsodium-wrappers-sumo';\nimport { Matter } from './matter';\nimport { MtrDex } from './matter';\nimport { Verfer } from './verfer';\nimport { Cigar } from './cigar';\nimport { Siger } from './siger';\nimport { IdrDex } from './indexer';\nimport { Buffer } from 'buffer';\n\n/**\n * @description Signer is Matter subclass with method to create signature of serialization\n * It will use .raw as signing (private) key seed\n * .code as cipher suite for signing and new property .verfer whose property\n *  .raw is public key for signing.\n *  If not provided .verfer is generated from private key seed using .code\n as cipher suite for creating key-pair.\n */\ninterface SignerArgs {\n    raw?: Uint8Array | undefined;\n    code?: string;\n    qb64b?: Uint8Array | undefined;\n    qb64?: string;\n    qb2?: Uint8Array | undefined;\n    transferable?: boolean;\n}\n\nexport class Signer extends Matter {\n    private readonly _sign: Function;\n    private readonly _verfer: Verfer;\n\n    constructor({\n        raw,\n        code = MtrDex.Ed25519_Seed,\n        qb64,\n        qb64b,\n        qb2,\n        transferable = true,\n    }: SignerArgs) {\n        try {\n            super({ raw, code, qb64, qb64b, qb2 });\n        } catch (e) {\n            if (e instanceof EmptyMaterialError) {\n                if (code == MtrDex.Ed25519_Seed) {\n                    const raw = libsodium.randombytes_buf(\n                        libsodium.crypto_sign_SEEDBYTES\n                    );\n                    super({ raw, code, qb64, qb64b, qb2 });\n                } else {\n                    throw new Error(`Unsupported signer code = ${code}.`);\n                }\n            } else {\n                throw e;\n            }\n        }\n        let verfer;\n        if (this.code == MtrDex.Ed25519_Seed) {\n            this._sign = this._ed25519;\n            const keypair = libsodium.crypto_sign_seed_keypair(this.raw);\n            verfer = new Verfer({\n                raw: keypair.publicKey,\n                code: transferable ? MtrDex.Ed25519 : MtrDex.Ed25519N,\n            });\n        } else {\n            throw new Error(`Unsupported signer code = ${this.code}.`);\n        }\n\n        this._verfer = verfer;\n    }\n\n    /**\n     * @description Property verfer:\n     Returns Verfer instance\n     Assumes ._verfer is correctly assigned\n     */\n    get verfer(): Verfer {\n        return this._verfer;\n    }\n\n    sign(\n        ser: Uint8Array,\n        index: number | null = null,\n        only: boolean = false,\n        ondex: number | undefined = undefined\n    ): Siger | Cigar {\n        return this._sign(ser, this.raw, this.verfer, index, only, ondex);\n    }\n\n    _ed25519(\n        ser: Uint8Array,\n        seed: Uint8Array,\n        verfer: Verfer,\n        index: number | null,\n        only: boolean = false,\n        ondex: number | undefined\n    ) {\n        const sig = libsodium.crypto_sign_detached(\n            ser,\n            Buffer.concat([seed, verfer.raw])\n        );\n\n        if (index == null) {\n            return new Cigar({ raw: sig, code: MtrDex.Ed25519_Sig }, verfer);\n        } else {\n            let code;\n            if (only) {\n                ondex = undefined;\n                if (index <= 63) {\n                    code = IdrDex.Ed25519_Crt_Sig;\n                } else {\n                    code = IdrDex.Ed25519_Big_Crt_Sig;\n                }\n            } else {\n                if (ondex == undefined) {\n                    ondex = index;\n                }\n\n                if (ondex == index && index <= 63)\n                    // both same and small\n                    code = IdrDex.Ed25519_Sig; //  use  small both same\n                //  otherwise big or both not same so use big both\n                else code = IdrDex.Ed25519_Big_Sig; // use use big both\n            }\n\n            return new Siger(\n                { raw: sig, code: code, index: index, ondex: ondex },\n                verfer\n            );\n        }\n    }\n}\n", "import { Verfer } from './verfer';\nimport { Matter, MatterArgs } from './matter';\n\nexport class Cigar extends Matter {\n    private _verfer: Verfer | undefined;\n    constructor({ raw, code, qb64, qb64b, qb2 }: MatterArgs, verfer?: Verfer) {\n        super({ raw, code, qb64, qb64b, qb2 });\n        this._verfer = verfer;\n    }\n\n    get verfer(): Verfer | undefined {\n        return this._verfer;\n    }\n\n    set verfer(verfer: Verfer | undefined) {\n        this._verfer = verfer;\n    }\n}\n", "import { EmptyMaterialError } from './kering';\nimport { b, b64ToInt, d, intToB64, readInt } from './core';\nimport { Buffer } from 'buffer';\nimport { decodeBase64Url, encodeBase64Url } from './base64';\n\nexport class IndexerCodex {\n    Ed25519_Sig: string = 'A'; // Ed25519 sig appears same in both lists if any.\n    Ed25519_Crt_Sig: string = 'B'; // Ed25519 sig appears in current list only.\n    ECDSA_256k1_Sig: string = 'C'; // ECDSA secp256k1 sig appears same in both lists if any.\n    ECDSA_256k1_Crt_Sig: string = 'D'; // ECDSA secp256k1 sig appears in current list.\n    ECDSA_256r1_Sig: string = 'E'; // ECDSA secp256r1 sig appears same in both lists if any.\n    ECDSA_256r1_Crt_Sig: string = 'F'; // ECDSA secp256r1 sig appears in current list.\n    Ed448_Sig: string = '0A'; // Ed448 signature appears in both lists.\n    Ed448_Crt_Sig: string = '0B'; // Ed448 signature appears in current list only.\n    Ed25519_Big_Sig: string = '2A'; // Ed25519 sig appears in both lists.\n    Ed25519_Big_Crt_Sig: string = '2B'; // Ed25519 sig appears in current list only.\n    ECDSA_256k1_Big_Sig: string = '2C'; // ECDSA secp256k1 sig appears in both lists.\n    ECDSA_256k1_Big_Crt_Sig: string = '2D'; // ECDSA secp256k1 sig appears in current list only.\n    ECDSA_256r1_Big_Sig: string = '2E'; // ECDSA secp256r1 sig appears in both lists.\n    ECDSA_256r1_Big_Crt_Sig: string = '2F'; // ECDSA secp256r1 sig appears in current list only.\n    Ed448_Big_Sig: string = '3A'; // Ed448 signature appears in both lists.\n    Ed448_Big_Crt_Sig: string = '3B'; // Ed448 signature appears in current list only.\n}\n\nexport const IdrDex = new IndexerCodex();\n\nexport class IndexedSigCodex {\n    Ed25519_Sig: string = 'A'; // Ed25519 sig appears same in both lists if any.\n    Ed25519_Crt_Sig: string = 'B'; // Ed25519 sig appears in current list only.\n    ECDSA_256k1_Sig: string = 'C'; // ECDSA secp256k1 sig appears same in both lists if any.\n    ECDSA_256k1_Crt_Sig: string = 'D'; // ECDSA secp256k1 sig appears in current list.\n    ECDSA_256r1_Sig: string = 'E'; // ECDSA secp256r1 sig appears same in both lists if any.\n    ECDSA_256r1_Crt_Sig: string = 'F'; // ECDSA secp256r1 sig appears in current list.\n    Ed448_Sig: string = '0A'; // Ed448 signature appears in both lists.\n    Ed448_Crt_Sig: string = '0B'; // Ed448 signature appears in current list only.\n    Ed25519_Big_Sig: string = '2A'; // Ed25519 sig appears in both lists.\n    Ed25519_Big_Crt_Sig: string = '2B'; // Ed25519 sig appears in current list only.\n    ECDSA_256k1_Big_Sig: string = '2C'; // ECDSA secp256k1 sig appears in both lists.\n    ECDSA_256k1_Big_Crt_Sig: string = '2D'; // ECDSA secp256k1 sig appears in current list only.\n    ECDSA_256r1_Big_Sig: string = '2E'; // ECDSA secp256r1 sig appears in both lists.\n    ECDSA_256r1_Big_Crt_Sig: string = '2F'; // ECDSA secp256r1 sig appears in current list only.\n    Ed448_Big_Sig: string = '3A'; // Ed448 signature appears in both lists.\n    Ed448_Big_Crt_Sig: string = '3B'; // Ed448 signature appears in current list only.\n\n    has(prop: string): boolean {\n        const m = new Map(\n            Array.from(Object.entries(this), (v) => [v[1], v[0]])\n        );\n        return m.has(prop);\n    }\n}\n\nexport const IdxSigDex = new IndexedSigCodex();\n\nexport class IndexedCurrentSigCodex {\n    Ed25519_Crt_Sig: string = 'B'; // Ed25519 sig appears in current list only.\n    ECDSA_256k1_Crt_Sig: string = 'D'; // ECDSA secp256k1 sig appears in current list only.\n    ECDSA_256r1_Crt_Sig: string = 'F'; // ECDSA secp256r1 sig appears in current list.\n    Ed448_Crt_Sig: string = '0B'; // Ed448 signature appears in current list only.\n    Ed25519_Big_Crt_Sig: string = '2B'; // Ed25519 sig appears in current list only.\n    ECDSA_256k1_Big_Crt_Sig: string = '2D'; // ECDSA secp256k1 sig appears in current list only.\n    ECDSA_256r1_Big_Crt_Sig: string = '2F'; // ECDSA secp256r1 sig appears in current list only.\n    Ed448_Big_Crt_Sig: string = '3B'; // Ed448 signature appears in current list only.\n\n    has(prop: string): boolean {\n        const m = new Map(\n            Array.from(Object.entries(this), (v) => [v[1], v[0]])\n        );\n        return m.has(prop);\n    }\n}\n\nexport const IdxCrtSigDex = new IndexedCurrentSigCodex();\n\nexport class IndexedBothSigCodex {\n    Ed25519_Sig: string = 'A'; // Ed25519 sig appears same in both lists if any.\n    ECDSA_256k1_Sig: string = 'C'; // ECDSA secp256k1 sig appears same in both lists if any.\n    Ed448_Sig: string = '0A'; // Ed448 signature appears in both lists.\n    Ed25519_Big_Sig: string = '2A'; // Ed25519 sig appears in both listsy.\n    ECDSA_256k1_Big_Sig: string = '2C'; // ECDSA secp256k1 sig appears in both lists.\n    Ed448_Big_Sig: string = '3A'; // Ed448 signature appears in both lists.\n\n    has(prop: string): boolean {\n        const m = new Map(\n            Array.from(Object.entries(this), (v) => [v[1], v[0]])\n        );\n        return m.has(prop);\n    }\n}\n\nexport const IdxBthSigDex = new IndexedBothSigCodex();\n\nexport class Xizage {\n    public hs: number;\n    public ss: number;\n    public os: number;\n    public fs?: number;\n    public ls: number;\n\n    constructor(hs: number, ss: number, os: number, fs?: number, ls?: number) {\n        this.hs = hs;\n        this.ss = ss;\n        this.os = os;\n        this.fs = fs;\n        this.ls = ls!;\n    }\n}\n\nexport interface IndexerArgs {\n    raw?: Uint8Array | undefined;\n    code?: string | undefined;\n    index?: number;\n    ondex?: number;\n    qb64b?: Uint8Array | undefined;\n    qb64?: string | undefined;\n    qb2?: Uint8Array | undefined;\n}\n\nexport class Indexer {\n    public Codex = IdrDex;\n\n    static Hards = new Map<string, number>([\n        ['A', 1],\n        ['B', 1],\n        ['C', 1],\n        ['D', 1],\n        ['E', 1],\n        ['F', 1],\n        ['G', 1],\n        ['H', 1],\n        ['I', 1],\n        ['J', 1],\n        ['K', 1],\n        ['L', 1],\n        ['M', 1],\n        ['N', 1],\n        ['O', 1],\n        ['P', 1],\n        ['Q', 1],\n        ['R', 1],\n        ['S', 1],\n        ['T', 1],\n        ['U', 1],\n        ['V', 1],\n        ['W', 1],\n        ['X', 1],\n        ['Y', 1],\n        ['Z', 1],\n        ['a', 1],\n        ['b', 1],\n        ['c', 1],\n        ['d', 1],\n        ['e', 1],\n        ['f', 1],\n        ['g', 1],\n        ['h', 1],\n        ['i', 1],\n        ['j', 1],\n        ['k', 1],\n        ['l', 1],\n        ['m', 1],\n        ['n', 1],\n        ['o', 1],\n        ['p', 1],\n        ['q', 1],\n        ['r', 1],\n        ['s', 1],\n        ['t', 1],\n        ['u', 1],\n        ['v', 1],\n        ['w', 1],\n        ['x', 1],\n        ['y', 1],\n        ['z', 1],\n        ['0', 2],\n        ['1', 2],\n        ['2', 2],\n        ['3', 2],\n        ['4', 2],\n    ]);\n\n    static Sizes = new Map(\n        Object.entries({\n            A: new Xizage(1, 1, 0, 88, 0),\n            B: new Xizage(1, 1, 0, 88, 0),\n            C: new Xizage(1, 1, 0, 88, 0),\n            D: new Xizage(1, 1, 0, 88, 0),\n            E: new Xizage(1, 1, 0, 88, 0),\n            F: new Xizage(1, 1, 0, 88, 0),\n            '0A': new Xizage(2, 2, 1, 156, 0),\n            '0B': new Xizage(2, 2, 1, 156, 0),\n\n            '2A': new Xizage(2, 4, 2, 92, 0),\n            '2B': new Xizage(2, 4, 2, 92, 0),\n            '2C': new Xizage(2, 4, 2, 92, 0),\n            '2D': new Xizage(2, 4, 2, 92, 0),\n            '2E': new Xizage(2, 4, 2, 92, 0),\n            '2F': new Xizage(2, 4, 2, 92, 0),\n\n            '3A': new Xizage(2, 6, 3, 160, 0),\n            '3B': new Xizage(2, 6, 3, 160, 0),\n\n            '0z': new Xizage(2, 2, 0, undefined, 0),\n            '1z': new Xizage(2, 2, 1, 76, 1),\n            '4z': new Xizage(2, 6, 3, 80, 1),\n        })\n    );\n\n    private _code: string = '';\n    private _index: number = -1;\n    private _ondex: number | undefined;\n    private _raw: Uint8Array = new Uint8Array(0);\n\n    constructor({\n        raw = undefined,\n        code = IdrDex.Ed25519_Sig,\n        index = 0,\n        ondex = undefined,\n        qb64b = undefined,\n        qb64 = undefined,\n        qb2 = undefined,\n    }: IndexerArgs) {\n        if (raw != undefined) {\n            if (code == undefined) {\n                throw new EmptyMaterialError(\n                    `Improper initialization need either (raw and code) or qb64b or qb64 or qb2.`\n                );\n            }\n\n            if (!Indexer.Sizes.has(code)) {\n                throw new Error(`Unsupported code=${code}.`);\n            }\n\n            const xizage = Indexer.Sizes.get(code)!;\n            const os = xizage.os;\n            const fs = xizage.fs;\n            const cs = xizage.hs + xizage.ss;\n            const ms = xizage.ss - xizage.os;\n\n            if (!Number.isInteger(index) || index < 0 || index > 64 ** ms - 1) {\n                throw new Error(`Invalid index=${index} for code=${code}.`);\n            }\n\n            if (\n                ondex != undefined &&\n                xizage.os != 0 &&\n                !(ondex >= 0 && ondex <= 64 ** os - 1)\n            ) {\n                throw new Error(`Invalid ondex=${ondex} for code=${code}.`);\n            }\n\n            if (IdxCrtSigDex.has(code) && ondex != undefined) {\n                throw new Error(`Non None ondex=${ondex} for code=${code}.`);\n            }\n\n            if (IdxBthSigDex.has(code)) {\n                if (ondex == undefined) {\n                    ondex = index;\n                } else {\n                    if (ondex != index && os == 0) {\n                        throw new Error(\n                            `Non matching ondex=${ondex} and index=${index} for code=${code}.`\n                        );\n                    }\n                }\n            }\n\n            if (fs == undefined) {\n                throw new Error('variable length unsupported');\n            }\n            // TODO: Don't support this code\n            //  if not fs:  # compute fs from index\n            //       if cs % 4:\n            //           raise InvalidCodeSizeError(f\"Whole code size not multiple of 4 for \"\n            //                                      f\"variable length material. cs={cs}.\")\n            //       if os != 0:\n            //           raise InvalidCodeSizeError(f\"Non-zero other index size for \"\n            //                                      f\"variable length material. os={os}.\")\n            //       fs = (index * 4) + cs\n            const rawsize = Math.floor(((fs - cs) * 3) / 4);\n            raw = raw.slice(0, rawsize);\n\n            if (raw.length != rawsize) {\n                throw new Error(\n                    `Not enougth raw bytes for code=${code} and index=${index} ,expected ${rawsize} got ${raw.length}.`\n                );\n            }\n\n            this._code = code;\n            this._index = index;\n            this._ondex = ondex;\n            this._raw = raw;\n        } else if (qb64b != undefined) {\n            const qb64 = d(qb64b);\n            this._exfil(qb64);\n        } else if (qb64 != undefined) {\n            this._exfil(qb64);\n        } else if (qb2 != undefined) {\n            this._bexfil(qb2);\n        } else {\n            throw new EmptyMaterialError(\n                `Improper initialization need either (raw and code and index) or qb64b or qb64 or qb2.`\n            );\n        }\n    }\n\n    private _bexfil(qb2: Uint8Array) {\n        throw new Error(`qb2 not yet supported: ${qb2}`);\n    }\n\n    public static _rawSize(code: string) {\n        const xizage = Indexer.Sizes.get(code)!;\n        return Math.floor(xizage.fs! - ((xizage.hs + xizage.ss) * 3) / 4);\n    }\n\n    get code(): string {\n        return this._code;\n    }\n\n    get raw(): Uint8Array {\n        return this._raw;\n    }\n\n    get index(): number {\n        return this._index;\n    }\n\n    get ondex(): number | undefined {\n        return this._ondex;\n    }\n\n    get qb64(): string {\n        return this._infil();\n    }\n\n    get qb64b() {\n        return b(this.qb64);\n    }\n\n    private _infil(): string {\n        const code = this.code;\n        const index = this.index;\n        const ondex = this.ondex;\n        const raw = this.raw;\n\n        const ps = (3 - (raw.length % 3)) % 3;\n        const xizage = Indexer.Sizes.get(code)!;\n        const cs = xizage.hs + xizage.ss;\n        const ms = xizage.ss - xizage.os;\n\n        // TODO: don't support this code\n        //  if not fs:  # compute fs from index\n        //       if cs % 4:\n        //           raise InvalidCodeSizeError(f\"Whole code size not multiple of 4 for \"\n        //                                      f\"variable length material. cs={cs}.\")\n        //       if os != 0:\n        //           raise InvalidCodeSizeError(f\"Non-zero other index size for \"\n        //                                      f\"variable length material. os={os}.\")\n        //       fs = (index * 4) + cs\n\n        if (index < 0 || index > 64 ** ms - 1) {\n            throw new Error(`Invalid index=${index} for code=${code}.`);\n        }\n\n        if (\n            ondex != undefined &&\n            xizage.os != 0 &&\n            !(ondex >= 0 && ondex <= 64 ** xizage.os - 1)\n        ) {\n            throw new Error(\n                `Invalid ondex=${ondex} for os=${xizage.os} and code=${code}.`\n            );\n        }\n\n        const both = `${code}${intToB64(index, ms)}${intToB64(\n            ondex == undefined ? 0 : ondex,\n            xizage.os\n        )}`;\n\n        if (both.length != cs) {\n            throw new Error(\n                `Mismatch code size = ${cs} with table = ${both.length}.`\n            );\n        }\n\n        if (cs % 4 != ps - xizage.ls) {\n            throw new Error(\n                `Invalid code=${both} for converted raw pad size=${ps}.`\n            );\n        }\n\n        const bytes = new Uint8Array(ps + raw.length);\n        for (let i = 0; i < ps; i++) {\n            bytes[i] = 0;\n        }\n        for (let i = 0; i < raw.length; i++) {\n            const odx = i + ps;\n            bytes[odx] = raw[i];\n        }\n\n        const full =\n            both + encodeBase64Url(Buffer.from(bytes)).slice(ps - xizage.ls);\n        if (full.length != xizage.fs) {\n            throw new Error(`Invalid code=${both} for raw size=${raw.length}.`);\n        }\n\n        return full;\n    }\n\n    _exfil(qb64: string) {\n        if (qb64.length == 0) {\n            throw new Error('Empty Material');\n        }\n\n        const first = qb64[0];\n        if (!Array.from(Indexer.Hards.keys()).includes(first)) {\n            throw new Error(`Unexpected code ${first}`);\n        }\n\n        const hs = Indexer.Hards.get(first)!;\n        if (qb64.length < hs) {\n            throw new Error(`Need ${hs - qb64.length} more characters.`);\n        }\n\n        const hard = qb64.slice(0, hs);\n        if (!Array.from(Indexer.Sizes.keys()).includes(hard)) {\n            throw new Error(`Unsupported code ${hard}`);\n        }\n\n        const xizage = Indexer.Sizes.get(hard)!;\n        const cs = xizage.hs + xizage.ss; // both hard + soft code size\n        const ms = xizage.ss - xizage.os;\n\n        if (qb64.length < cs) {\n            throw new Error(`Need ${cs - qb64.length} more characters.`);\n        }\n\n        const sindex = qb64.slice(hs, hs + ms);\n        const index = b64ToInt(sindex);\n\n        const sondex = qb64.slice(hs + ms, hs + ms + xizage.os);\n        let ondex;\n        if (IdxCrtSigDex.has(hard)) {\n            ondex = xizage.os != 0 ? b64ToInt(sondex) : undefined;\n            if (ondex != 0 && ondex != undefined) {\n                throw new Error(`Invalid ondex=${ondex} for code=${hard}.`);\n            } else {\n                ondex = undefined;\n            }\n        } else {\n            ondex = xizage.os != 0 ? b64ToInt(sondex) : index;\n        }\n\n        if (xizage.fs == undefined) {\n            throw new Error('variable length not supported');\n        }\n        // TODO: support variable length\n        // if not fs:  # compute fs from index which means variable length\n        //     if cs % 4:\n        //         raise ValidationError(f\"Whole code size not multiple of 4 for \"\n        //                               f\"variable length material. cs={cs}.\")\n        //     if os != 0:\n        //         raise ValidationError(f\"Non-zero other index size for \"\n        //                               f\"variable length material. os={os}.\")\n        //     fs = (index * 4) + cs\n\n        if (qb64.length < xizage.fs) {\n            throw new Error(`Need ${xizage.fs - qb64.length} more chars.`);\n        }\n\n        qb64 = qb64.slice(0, xizage.fs);\n        const ps = cs % 4;\n        const pbs = 2 * ps != 0 ? ps : xizage.ls;\n        let raw;\n        if (ps != 0) {\n            const base = new Array(ps + 1).join('A') + qb64.slice(cs);\n            const paw = decodeBase64Url(base); // decode base to leave prepadded raw\n            const pi = readInt(paw.slice(0, ps)); // prepad as int\n            if (pi & (2 ** pbs - 1)) {\n                // masked pad bits non-zero\n                throw new Error(\n                    `Non zeroed prepad bits = {pi & (2 ** pbs - 1 ):<06b} in {qb64b[cs:cs+1]}.`\n                );\n            }\n            raw = paw.slice(ps); // strip off ps prepad paw bytes\n        } else {\n            const base = qb64.slice(cs);\n            const paw = decodeBase64Url(base);\n            const li = readInt(paw.slice(0, xizage!.ls));\n            if (li != 0) {\n                if (li == 1) {\n                    throw new Error(`Non zeroed lead byte = 0x{li:02x}.`);\n                } else {\n                    throw new Error(`Non zeroed lead bytes = 0x{li:04x}`);\n                }\n            }\n            raw = paw.slice(xizage!.ls);\n        }\n\n        if (raw.length != Math.floor(((qb64.length - cs) * 3) / 4)) {\n            throw new Error(`Improperly qualified material = ${qb64}`);\n        }\n\n        this._code = hard;\n        this._index = index;\n        this._ondex = ondex;\n        this._raw = new Uint8Array(raw); // must be bytes for crpto opts and immutable not bytearray\n    }\n}\n", "import { IdxSigDex, Indexer, IndexerArgs } from './indexer';\nimport { Verfer } from './verfer';\n\n/**\n   Siger is subclass of Indexer, indexed signature material,\n    Adds .verfer property which is instance of Verfer that provides\n          associated signature verifier.\n\n    See Indexer for inherited attributes and properties:\n\n    Attributes:\n\n    Properties:\n        .verfer is Verfer object instance\n\n    Methods:\n **/\n\nexport class Siger extends Indexer {\n    private _verfer?: Verfer;\n    constructor(\n        { raw, code, index, ondex, qb64, qb64b, qb2 }: IndexerArgs,\n        verfer?: Verfer\n    ) {\n        super({ raw, code, index, ondex, qb64, qb64b, qb2 });\n\n        if (!IdxSigDex.has(this.code)) {\n            throw new Error(`Invalid code = ${this.code} for Siger.`);\n        }\n        this._verfer = verfer;\n    }\n\n    get verfer(): Verfer | undefined {\n        return this._verfer;\n    }\n\n    set verfer(verfer: Verfer | undefined) {\n        this._verfer = verfer;\n    }\n}\n", "import libsodium from 'libsodium-wrappers-sumo';\n\nimport { Matter, MatterArgs, MtrDex } from './matter';\nimport { Signer } from './signer';\nimport { Cipher } from './cipher';\nimport { EmptyMaterialError } from './kering';\nimport { Salter } from './salter';\n\nexport class Decrypter extends Matter {\n    private readonly _decrypt: any;\n    constructor(\n        { raw, code = MtrDex.X25519_Private, qb64, qb64b, qb2 }: MatterArgs,\n        seed: Uint8Array | undefined = undefined\n    ) {\n        try {\n            super({ raw, code, qb64, qb64b, qb2 });\n        } catch (e) {\n            if (e instanceof EmptyMaterialError) {\n                if (seed != undefined) {\n                    const signer = new Signer({ qb64b: seed });\n                    if (signer.code != MtrDex.Ed25519_Seed) {\n                        throw new Error(\n                            `Unsupported signing seed derivation code ${signer.code}`\n                        );\n                    }\n                    const sigkey = new Uint8Array(\n                        signer.raw.length + signer.verfer.raw.length\n                    );\n                    sigkey.set(signer.raw);\n                    sigkey.set(signer.verfer.raw, signer.raw.length);\n                    raw =\n                        libsodium.crypto_sign_ed25519_sk_to_curve25519(sigkey);\n                    super({ raw, code, qb64, qb64b, qb2 });\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n\n        if (this.code == MtrDex.X25519_Private) {\n            this._decrypt = this._x25519;\n        } else {\n            throw new Error(`Unsupported decrypter code = ${this.code}.`);\n        }\n    }\n\n    decrypt(\n        ser: Uint8Array | null = null,\n        cipher: Cipher | null = null,\n        transferable: boolean = false\n    ) {\n        if (ser == null && cipher == null) {\n            throw new EmptyMaterialError('Neither ser or cipher were provided');\n        }\n\n        if (ser != null) {\n            cipher = new Cipher({ qb64b: ser });\n        }\n\n        return this._decrypt(cipher, this.raw, transferable);\n    }\n\n    _x25519(cipher: Cipher, prikey: Uint8Array, transferable: boolean = false) {\n        const pubkey = libsodium.crypto_scalarmult_base(prikey);\n        const plain = libsodium.crypto_box_seal_open(\n            cipher.raw,\n            pubkey,\n            prikey\n        );\n        if (cipher.code == MtrDex.X25519_Cipher_Salt) {\n            return new Salter({ qb64b: plain });\n        } else if (cipher.code == MtrDex.X25519_Cipher_Seed) {\n            return new Signer({ qb64b: plain, transferable: transferable });\n        } else {\n            throw new Error(`Unsupported cipher text code == ${cipher.code}`);\n        }\n    }\n}\n", "import { Signer } from './signer';\n\nimport { Matter, MtrDex } from './matter';\nimport { EmptyMaterialError } from './kering';\nimport libsodium from 'libsodium-wrappers-sumo';\n\nexport enum Tier {\n    low = 'low',\n    med = 'med',\n    high = 'high',\n}\n\ninterface SalterArgs {\n    raw?: Uint8Array | undefined;\n    code?: string;\n    tier?: Tier;\n    qb64b?: Uint8Array | undefined;\n    qb64?: string;\n    qb2?: Uint8Array | undefined;\n}\nexport class Salter extends Matter {\n    private readonly _tier: Tier | null;\n\n    constructor({\n        raw,\n        code = MtrDex.Salt_128,\n        tier = Tier.low,\n        qb64,\n        qb64b,\n        qb2,\n    }: SalterArgs) {\n        try {\n            super({ raw, code, qb64, qb64b, qb2 });\n        } catch (e) {\n            if (e instanceof EmptyMaterialError) {\n                if (code == MtrDex.Salt_128) {\n                    const salt = libsodium.randombytes_buf(\n                        libsodium.crypto_pwhash_SALTBYTES\n                    );\n                    super({ raw: salt, code: code });\n                } else {\n                    throw new Error(\n                        'invalid code for Salter, only Salt_128 accepted'\n                    );\n                }\n            } else {\n                throw e;\n            }\n        }\n\n        if (this.code != MtrDex.Salt_128) {\n            throw new Error('invalid code for Salter, only Salt_128 accepted');\n        }\n\n        this._tier = tier !== null ? tier : Tier.low;\n    }\n\n    private stretch(\n        size: number = 32,\n        path: string = '',\n        tier: Tier | null = null,\n        temp: boolean = false\n    ): Uint8Array {\n        tier = tier == null ? this.tier : tier;\n\n        let opslimit: number, memlimit: number;\n\n        // Harcoded values based on keripy\n        if (temp) {\n            opslimit = 1; //libsodium.crypto_pwhash_OPSLIMIT_MIN\n            memlimit = 8192; //libsodium.crypto_pwhash_MEMLIMIT_MIN\n        } else {\n            switch (tier) {\n                case Tier.low:\n                    opslimit = 2; //libsodium.crypto_pwhash_OPSLIMIT_INTERACTIVE\n                    memlimit = 67108864; //libsodium.crypto_pwhash_MEMLIMIT_INTERACTIVE\n                    break;\n                case Tier.med:\n                    opslimit = 3; //libsodium.crypto_pwhash_OPSLIMIT_MODERATE\n                    memlimit = 268435456; //libsodium.crypto_pwhash_MEMLIMIT_MODERATE\n                    break;\n                case Tier.high:\n                    opslimit = 4; //libsodium.crypto_pwhash_OPSLIMIT_SENSITIVE\n                    memlimit = 1073741824; //libsodium.crypto_pwhash_MEMLIMIT_SENSITIVE\n                    break;\n                default:\n                    throw new Error(`Unsupported security tier = ${tier}.`);\n            }\n        }\n\n        return libsodium.crypto_pwhash(\n            size,\n            path,\n            this.raw,\n            opslimit,\n            memlimit,\n            libsodium.crypto_pwhash_ALG_ARGON2ID13\n        );\n    }\n\n    signer(\n        code: string = MtrDex.Ed25519_Seed,\n        transferable: boolean = true,\n        path: string = '',\n        tier: Tier | null = null,\n        temp: boolean = false\n    ): Signer {\n        const seed = this.stretch(Matter._rawSize(code), path, tier, temp);\n\n        return new Signer({\n            raw: seed,\n            code: code,\n            transferable: transferable,\n        });\n    }\n\n    get tier(): Tier | null {\n        return this._tier;\n    }\n}\n", "import { Matter, MatterArgs, MtrDex } from './matter';\nimport { Decrypter } from './decrypter';\n\nexport class Cipher extends Matter {\n    constructor({ raw, code, qb64, qb64b, qb2 }: MatterArgs) {\n        if (raw != undefined && code == undefined) {\n            if (raw.length == Matter._rawSize(MtrDex.X25519_Cipher_Salt)) {\n                code = MtrDex.X25519_Cipher_Salt;\n            } else if (\n                raw.length == Matter._rawSize(MtrDex.X25519_Cipher_Seed)\n            ) {\n                code = MtrDex.X25519_Cipher_Salt;\n            }\n        }\n        super({ raw: raw, code: code, qb64b: qb64b, qb64: qb64, qb2: qb2 });\n\n        if (\n            !Array.from([\n                MtrDex.X25519_Cipher_Salt,\n                MtrDex.X25519_Cipher_Seed,\n            ]).includes(this.code)\n        ) {\n            throw new Error(`Unsupported Cipher code == ${this.code}`);\n        }\n    }\n\n    decrypt(\n        prikey: Uint8Array | undefined = undefined,\n        seed: Uint8Array | undefined = undefined\n    ) {\n        const decrypter = new Decrypter({ qb64b: prikey }, seed);\n        return decrypter.decrypt(this.qb64b);\n    }\n}\n", "import { Codex, Sizage } from './matter';\nimport { b, b64ToInt, d, intToB64 } from './core';\n\nexport interface CounterArgs {\n    code?: string;\n    count?: number;\n    countB64?: string;\n    qb64b?: Uint8Array;\n    qb64?: string;\n    qb2?: Uint8Array;\n    strip?: boolean;\n}\n\nexport class CounterCodex extends Codex {\n    public ControllerIdxSigs: string = '-A'; // Qualified Base64 Indexed Signature.\n    public WitnessIdxSigs: string = '-B'; // Qualified Base64 Indexed Signature.\n    public NonTransReceiptCouples: string = '-C'; // Composed Base64 Couple, pre+cig.\n    public TransReceiptQuadruples: string = '-D'; // Composed Base64 Quadruple, pre+snu+dig+sig.\n    public FirstSeenReplayCouples: string = '-E'; // Composed Base64 Couple, fnu+dts.\n    public TransIdxSigGroups: string = '-F'; // Composed Base64 Group, pre+snu+dig+ControllerIdxSigs group.\n    public SealSourceCouples: string = '-G'; // Composed Base64 couple, snu+dig of given delegators or issuers event\n    public TransLastIdxSigGroups: string = '-H'; // Composed Base64 Group, pre+ControllerIdxSigs group.\n    public SealSourceTriples: string = '-I'; // Composed Base64 triple, pre+snu+dig of anchoring source event\n    public SadPathSig: string = '-J'; // Composed Base64 Group path+TransIdxSigGroup of SAID of content\n    public SadPathSigGroup: string = '-K'; // Composed Base64 Group, root(path)+SaidPathCouples\n    public PathedMaterialQuadlets: string = '-L'; // Composed Grouped Pathed Material Quadlet (4 char each)\n    public AttachedMaterialQuadlets: string = '-V'; // Composed Grouped Attached Material Quadlet (4 char each)\n    public BigAttachedMaterialQuadlets: string = '-0V'; // Composed Grouped Attached Material Quadlet (4 char each)\n    public KERIProtocolStack: string = '--AAA'; // KERI ACDC Protocol Stack CESR Version\n}\n\nexport const CtrDex = new CounterCodex();\n\nexport class Counter {\n    static Sizes = new Map(\n        Object.entries({\n            '-A': new Sizage(2, 2, 4, 0),\n            '-B': new Sizage(2, 2, 4, 0),\n            '-C': new Sizage(2, 2, 4, 0),\n            '-D': new Sizage(2, 2, 4, 0),\n            '-E': new Sizage(2, 2, 4, 0),\n            '-F': new Sizage(2, 2, 4, 0),\n            '-G': new Sizage(2, 2, 4, 0),\n            '-H': new Sizage(2, 2, 4, 0),\n            '-I': new Sizage(2, 2, 4, 0),\n            '-J': new Sizage(2, 2, 4, 0),\n            '-K': new Sizage(2, 2, 4, 0),\n            '-L': new Sizage(2, 2, 4, 0),\n            '-V': new Sizage(2, 2, 4, 0),\n            '-0V': new Sizage(3, 5, 8, 0),\n            '--AAA': new Sizage(5, 3, 8, 0),\n        })\n    );\n\n    static Hards = new Map<string, number>([\n        ['-A', 2],\n        ['-B', 2],\n        ['-C', 2],\n        ['-D', 2],\n        ['-E', 2],\n        ['-F', 2],\n        ['-G', 2],\n        ['-H', 2],\n        ['-I', 2],\n        ['-J', 2],\n        ['-K', 2],\n        ['-L', 2],\n        ['-M', 2],\n        ['-N', 2],\n        ['-O', 2],\n        ['-P', 2],\n        ['-Q', 2],\n        ['-R', 2],\n        ['-S', 2],\n        ['-T', 2],\n        ['-U', 2],\n        ['-V', 2],\n        ['-W', 2],\n        ['-X', 2],\n        ['-Y', 2],\n        ['-Z', 2],\n        ['-a', 2],\n        ['-b', 2],\n        ['-c', 2],\n        ['-d', 2],\n        ['-e', 2],\n        ['-f', 2],\n        ['-g', 2],\n        ['-h', 2],\n        ['-i', 2],\n        ['-j', 2],\n        ['-k', 2],\n        ['-l', 2],\n        ['-m', 2],\n        ['-n', 2],\n        ['-o', 2],\n        ['-p', 2],\n        ['-q', 2],\n        ['-r', 2],\n        ['-s', 2],\n        ['-t', 2],\n        ['-u', 2],\n        ['-v', 2],\n        ['-w', 2],\n        ['-x', 2],\n        ['-y', 2],\n        ['-z', 2],\n        ['-0', 3],\n        ['--', 5],\n    ]);\n\n    private _code: string = '';\n    private _count: number = -1;\n\n    constructor({ code, count, countB64, qb64b, qb64, qb2 }: CounterArgs) {\n        if (code != undefined) {\n            if (!Counter.Sizes.has(code)) {\n                throw new Error(`\"Unsupported code=${code}.`);\n            }\n\n            const sizage = Counter.Sizes.get(code)!;\n            const cs = sizage.hs + sizage.ss;\n            if (sizage.fs != cs || cs % 4 != 0) {\n                throw new Error(\n                    `Whole code size not full size or not multiple of 4. cs=${cs} fs=${sizage.fs}.`\n                );\n            }\n\n            if (count == undefined) {\n                count = countB64 == undefined ? 1 : b64ToInt(countB64);\n            }\n\n            if (count < 0 || count > 64 ** sizage.ss - 1) {\n                throw new Error(`Invalid count=${count} for code=${code}.`);\n            }\n\n            this._code = code;\n            this._count = count;\n        } else if (qb64b != undefined) {\n            const qb64 = d(qb64b);\n            this._exfil(qb64);\n        } else if (qb64 != undefined) {\n            this._exfil(qb64);\n        } else if (qb2 != undefined) {\n        } else {\n            throw new Error(\n                `Improper initialization need either (code and count) or qb64b or qb64 or qb2.`\n            );\n        }\n    }\n\n    get code(): string {\n        return this._code;\n    }\n\n    get count() {\n        return this._count;\n    }\n\n    get qb64() {\n        return this._infil();\n    }\n\n    get qb64b() {\n        return b(this.qb64);\n    }\n\n    countToB64(l?: number): string {\n        if (l == undefined) {\n            const sizage = Counter.Sizes.get(this.code)!;\n            l = sizage.ss;\n        }\n        return intToB64(this.count, l);\n    }\n\n    static semVerToB64(\n        version: string = '',\n        major: number = 0,\n        minor: number = 0,\n        patch: number = 0\n    ): string {\n        let parts = [major, minor, patch];\n        if (version != '') {\n            const ssplits = version.split('.');\n            const splits = ssplits.map((x) => {\n                if (x == '') return 0;\n                return parseInt(x);\n            });\n\n            const off = splits.length;\n            const x = 3 - off;\n            for (let i = 0; i < x; i++) {\n                splits.push(parts[i + off]);\n            }\n            parts = splits;\n        }\n\n        parts.forEach((p) => {\n            if (p < 0 || p > 63) {\n                throw new Error(\n                    `Out of bounds semantic version. Part=${p} is < 0 or > 63.`\n                );\n            }\n        });\n\n        return parts\n            .map((p) => {\n                return intToB64(p, 1);\n            })\n            .join('');\n    }\n\n    private _infil(): string {\n        const code = this.code;\n        const count = this.count;\n\n        const sizage = Counter.Sizes.get(code)!;\n        const cs = sizage.hs + sizage.ss;\n        if (sizage.fs != cs || cs % 4 != 0) {\n            throw new Error(\n                `Whole code size not full size or not multiple of 4. cs=${cs} fs=${sizage.fs}.`\n            );\n        }\n\n        if (count < 0 || count > 64 ** sizage.ss - 1) {\n            throw new Error(`Invalid count=${count} for code=${code}.`);\n        }\n\n        const both = `${code}${intToB64(count, sizage.ss)}`;\n\n        if (both.length % 4) {\n            throw new Error(\n                `Invalid size = ${both.length} of ${both} not a multiple of 4.`\n            );\n        }\n\n        return both;\n    }\n\n    private _exfil(qb64: string) {\n        if (qb64.length == 0) {\n            throw new Error('Empty Material');\n        }\n\n        const first = qb64.slice(0, 2);\n        if (!Counter.Hards.has(first)) {\n            throw new Error(`Unexpected code ${first}`);\n        }\n\n        const hs = Counter.Hards.get(first)!;\n        if (qb64.length < hs) {\n            throw new Error(`Need ${hs - qb64.length} more characters.`);\n        }\n\n        const hard = qb64.slice(0, hs);\n        if (!Counter.Sizes.has(hard)) {\n            throw new Error(`Unsupported code ${hard}`);\n        }\n\n        const sizage = Counter.Sizes.get(hard)!;\n        const cs = sizage!.hs + sizage!.ss;\n\n        if (qb64.length < cs) {\n            throw new Error(`Need ${cs - qb64.length} more chars.`);\n        }\n\n        const scount = qb64.slice(sizage.hs, sizage.hs + sizage.ss);\n        const count = b64ToInt(scount);\n\n        this._code = hard;\n        this._count = count;\n    }\n}\n", "import { Matter, MatterArgs, MtrDex } from './matter';\nimport { intToBytes, bytesToInt } from './utils';\n/**\n * @description  Seqner: subclass of Matter, cryptographic material, for ordinal numbers\n * such as sequence numbers or first seen ordering numbers.\n * Seqner provides fully qualified format for ordinals (sequence numbers etc)\n * when provided as attached cryptographic material elements.\n */\nexport class Seqner extends Matter {\n    constructor({\n        raw,\n        code = MtrDex.Salt_128,\n        qb64,\n        qb64b,\n        qb2,\n        sn,\n        snh,\n        ...kwa\n    }: MatterArgs & { sn?: number; snh?: string }) {\n        if (!raw && !qb64b && !qb64 && !qb2) {\n            if (sn === undefined) {\n                if (snh === undefined) {\n                    sn = 0;\n                } else {\n                    sn = parseInt(snh, 16);\n                }\n            }\n\n            raw = intToBytes(sn, Matter._rawSize(MtrDex.Salt_128));\n        }\n\n        super({ raw, code, qb64, qb64b, qb2, ...kwa });\n\n        if (this.code !== MtrDex.Salt_128) {\n            throw new Error(`Invalid code = ${this.code} for Seqner.`);\n        }\n    }\n\n    get sn(): number {\n        return bytesToInt(this.raw); //To check if other readUInt64 is needed\n    }\n\n    get snh(): string {\n        return this.sn.toString(16);\n    }\n}\n", "import { blake3 } from '@noble/hashes/blake3';\nimport { Buffer } from 'buffer';\nimport { Matter, MatterArgs, MtrDex } from './matter';\n\n/**\n * @description : Diger is subset of Matter and is used to verify the digest of serialization\n * It uses  .raw : as digest\n * .code as digest algorithm\n *\n */\n\nexport class Diger extends Matter {\n    private readonly _verify: any;\n\n    // This constructor will assign digest verification function to ._verify\n    constructor(\n        { raw, code = MtrDex.Blake3_256, qb64, qb64b, qb2 }: MatterArgs,\n        ser: Uint8Array | null = null\n    ) {\n        try {\n            super({ raw, code, qb64, qb64b, qb2 });\n        } catch (error) {\n            if (ser == null) {\n                throw error;\n            }\n\n            if (code === MtrDex.Blake3_256) {\n                const dig = Buffer.from(\n                    blake3.create({ dkLen: 32 }).update(ser).digest()\n                );\n                super({ raw: dig, code: code });\n            } else {\n                throw new Error(`Unsupported code = ${code} for digester.`);\n            }\n        }\n\n        if (code === MtrDex.Blake3_256) {\n            this._verify = this.blake3_256;\n        } else {\n            throw new Error(`Unsupported code = ${code} for digester.`);\n        }\n    }\n\n    /**\n     *\n     * @param {Uint8Array} ser  serialization bytes\n     * @description  This method will return true if digest of bytes serialization ser matches .raw\n     * using .raw as reference digest for ._verify digest algorithm determined\n     by .code\n     */\n    verify(ser: Uint8Array): boolean {\n        return this._verify(ser, this.raw);\n    }\n\n    compare(ser: Uint8Array, dig: any = null, diger: Diger | null = null) {\n        if (dig != null) {\n            if (dig.toString() == this.qb64) {\n                return true;\n            }\n\n            diger = new Diger({ qb64b: dig });\n        } else if (diger != null) {\n            if (diger.qb64b == this.qb64b) {\n                return true;\n            }\n        } else {\n            throw new Error('Both dig and diger may not be None.');\n        }\n\n        if (diger.code == this.code) {\n            return false;\n        }\n\n        return diger.verify(ser) && this.verify(ser);\n    }\n\n    blake3_256(ser: Uint8Array, dig: any) {\n        const digest = Buffer.from(\n            blake3.create({ dkLen: 32 }).update(ser).digest()\n        );\n        return digest.toString() === dig.toString();\n    }\n}\n", "import { Matter, MatterArgs, NumDex } from './matter';\nimport { bytesToInt, intToBytes } from './utils';\n\nexport class CesrNumber extends Matter {\n    constructor(\n        { raw, code, qb64b, qb64, qb2 }: MatterArgs,\n        num?: number | string,\n        numh?: string\n    ) {\n        let _num;\n        if (\n            raw == undefined &&\n            qb64 == undefined &&\n            qb64b == undefined &&\n            qb2 == undefined\n        ) {\n            if (typeof num == 'number') {\n                _num = num;\n            } else if (numh != undefined) {\n                _num = parseInt(numh, 16);\n            } else {\n                _num = 0;\n            }\n        }\n\n        if (_num == undefined) {\n            throw new Error('Invalid whole number');\n        }\n\n        if (_num <= 256 ** 2 - 1) {\n            // make short version of code\n            code = NumDex.Short;\n        } else if (_num <= 256 ** 4 - 1) {\n            // make long version of code\n            code = code = NumDex.Long;\n        } else if (_num <= 256 ** 8 - 1) {\n            // make big version of code\n            code = code = NumDex.Big;\n        } else if (_num <= 256 ** 16 - 1) {\n            // make huge version of code\n            code = code = NumDex.Huge;\n        } else {\n            throw new Error(`Invalid num = ${num}, too large to encode.`);\n        }\n\n        raw = intToBytes(_num, Matter._rawSize(code));\n\n        super({ raw, code, qb64b, qb64, qb2 });\n\n        if (!NumDex.has(this.code)) {\n            throw new Error('Invalid code ' + code + ' for Number');\n        }\n    }\n\n    get num(): number {\n        return bytesToInt(this.raw);\n    }\n\n    get numh(): string {\n        return this.num.toString(16);\n    }\n\n    get positive(): boolean {\n        return this.num > 0;\n    }\n}\n", "import { MtrDex } from './matter';\nimport {\n    deversify,\n    Dict,\n    Ident,\n    Serials,\n    versify,\n    Version,\n    Versionage,\n} from './core';\nimport { Verfer } from './verfer';\nimport { Diger } from './diger';\nimport { CesrNumber } from './number';\n\nexport class Serder {\n    private _kind: Serials;\n    private _raw: string = '';\n    private _ked: Dict<any> = {};\n    private _ident: Ident = Ident.KERI;\n    private _size: number = 0;\n    private _version: Version = Versionage;\n    private readonly _code: string;\n\n    constructor(\n        ked: Dict<any>,\n        kind: Serials = Serials.JSON,\n        code: string = MtrDex.Blake3_256\n    ) {\n        this._code = code;\n        this._kind = kind;\n        this.ked = ked;\n    }\n\n    set ked(ked: Dict<any>) {\n        const [raw, ident, kind, kd, version] = this._exhale(ked, this._kind);\n        const size = raw.length;\n        this._raw = raw;\n        this._ident = ident;\n        this._ked = kd;\n        this._kind = kind;\n        this._size = size;\n        this._version = version;\n    }\n\n    get pre(): string {\n        return this._ked['i'];\n    }\n\n    get ked(): Dict<any> {\n        return this._ked;\n    }\n\n    get code(): string {\n        return this._code;\n    }\n\n    get raw(): string {\n        return this._raw;\n    }\n\n    get sner(): CesrNumber {\n        return new CesrNumber({}, this.ked['s']);\n    }\n\n    get sn(): number {\n        return this.sner.num;\n    }\n\n    get kind(): Serials {\n        return this._kind;\n    }\n\n    private _exhale(\n        ked: Dict<any>,\n        kind: Serials\n    ): [string, Ident, Serials, Dict<any>, Version] {\n        return sizeify(ked, kind);\n    }\n\n    get ident(): Ident {\n        return this._ident;\n    }\n\n    get size(): number {\n        return this._size;\n    }\n\n    get version(): Version {\n        return this._version;\n    }\n    get verfers(): Verfer[] {\n        let keys: any = [];\n        if ('k' in this._ked) {\n            // establishment event\n            keys = this._ked['k'];\n        } else {\n            // non-establishment event\n            keys = [];\n        }\n        // create a new Verfer for each key\n        const verfers = [];\n        for (const key of keys) {\n            verfers.push(new Verfer({ qb64: key }));\n        }\n        return verfers;\n    }\n\n    get digers(): Diger[] {\n        let keys: any = [];\n        if ('n' in this._ked) {\n            // establishment event\n            keys = this._ked['n'];\n        } else {\n            // non-establishment event\n            keys = [];\n        }\n        // create a new Verfer for each key\n        const digers = [];\n        for (const key of keys) {\n            digers.push(new Diger({ qb64: key }));\n        }\n        return digers;\n    }\n\n    pretty() {\n        return JSON.stringify(this._ked, undefined, 2);\n    }\n}\n\nexport function dumps(ked: Object, kind: Serials.JSON): string {\n    if (kind == Serials.JSON) {\n        return JSON.stringify(ked);\n    } else {\n        throw new Error('unsupported event encoding');\n    }\n}\n\nexport function sizeify(\n    ked: Dict<any>,\n    kind?: Serials\n): [string, Ident, Serials, Dict<any>, Version] {\n    if (!('v' in ked)) {\n        throw new Error('Missing or empty version string');\n    }\n\n    const [ident, knd, version] = deversify(ked['v'] as string);\n    if (version != Versionage) {\n        throw new Error(`unsupported version ${version.toString()}`);\n    }\n\n    if (kind == undefined) {\n        kind = knd;\n    }\n\n    let raw = dumps(ked, kind);\n    const size = new TextEncoder().encode(raw).length;\n\n    ked['v'] = versify(ident, version, kind, size);\n\n    raw = dumps(ked, kind);\n\n    return [raw, ident, kind, ked, version];\n}\n", "import { Matter, MatterArgs, MtrDex } from './matter';\nimport { EmptyMaterialError } from './kering';\nimport { Dict, Ilks } from './core';\nimport { sizeify } from './serder';\nimport { Verfer } from './verfer';\nimport { Buffer } from 'buffer';\nimport { blake3 } from '@noble/hashes/blake3';\n\nconst Dummy: string = '#';\n\nexport class Prefixer extends Matter {\n    private readonly _derive: Function | undefined;\n    private readonly _verify: Function | undefined;\n\n    constructor({ raw, code, qb64b, qb64, qb2 }: MatterArgs, ked?: Dict<any>) {\n        try {\n            super({ raw, code, qb64b, qb64, qb2 });\n        } catch (e) {\n            if (e instanceof EmptyMaterialError) {\n                if (ked == undefined || (code == undefined && !('i' in ked))) {\n                    throw e;\n                }\n\n                if (code == undefined) {\n                    super({ qb64: ked['i'], code: code });\n                    code = this.code;\n                }\n\n                let _derive;\n                if (code == MtrDex.Ed25519N) {\n                    _derive = Prefixer._derive_ed25519N;\n                } else if (code == MtrDex.Ed25519) {\n                    _derive = Prefixer._derive_ed25519;\n                } else if (code == MtrDex.Blake3_256) {\n                    _derive = Prefixer._derive_blake3_256;\n                } else {\n                    throw new Error(`Unsupported code = ${code} for prefixer.`);\n                }\n\n                [raw, code] = _derive(ked);\n                super({ raw: raw, code: code });\n                this._derive = _derive;\n            } else {\n                throw e;\n            }\n        }\n\n        if (this.code == MtrDex.Ed25519N) {\n            this._verify = this._verify_ed25519N;\n        } else if (this.code == MtrDex.Ed25519) {\n            this._verify = this._verify_ed25519;\n        } else if (this.code == MtrDex.Blake3_256) {\n            this._verify = this._verify_blake3_256;\n        } else {\n            throw new Error(`Unsupported code = ${code} for prefixer.`);\n        }\n    }\n\n    derive(ked: Dict<any>): [Uint8Array, string] {\n        if (ked['i'] != Ilks.icp) {\n            throw new Error(\n                `Non-incepting ilk ${ked['i']} for prefix derivation`\n            );\n        }\n        return this._derive!(ked);\n    }\n\n    verify(ked: Dict<any>, prefixed: boolean = false): boolean {\n        if (ked['i'] != Ilks.icp) {\n            throw new Error(\n                `Non-incepting ilk ${ked['i']} for prefix derivation`\n            );\n        }\n        return this._verify!(ked, this.qb64, prefixed);\n    }\n\n    static _derive_ed25519N(ked: Dict<any>): [Uint8Array, string] {\n        let verfer;\n        const keys = ked['k'];\n        if (keys.length != 1) {\n            throw new Error(\n                `Basic derivation needs at most 1 key got ${keys.length} keys instead`\n            );\n        }\n        try {\n            verfer = new Verfer({ qb64: keys[0] });\n        } catch (e) {\n            throw new Error(`Error extracting public key = ${e}`);\n        }\n\n        if (verfer.code != MtrDex.Ed25519N) {\n            throw new Error(`Mismatch derivation code = ${verfer.code}`);\n        }\n\n        const next = 'n' in ked ? ked['n'] : [];\n        if (verfer.code == MtrDex.Ed25519N && next.length > 0) {\n            throw new Error(\n                `Non-empty nxt = ${next} for non-transferable code = ${verfer.code}`\n            );\n        }\n\n        const backers = 'b' in ked ? ked['b'] : [];\n        if (verfer.code == MtrDex.Ed25519N && backers.length > 0) {\n            throw new Error(\n                `Non-empty b =${backers} for non-transferable code = ${verfer.code}`\n            );\n        }\n\n        const anchor = 'a' in ked ? ked['a'] : [];\n        if (verfer.code == MtrDex.Ed25519N && anchor.length > 0) {\n            throw new Error(\n                `Non-empty a = ${verfer.code} for non-transferable code = ${verfer.code}`\n            );\n        }\n\n        return [verfer.raw, verfer.code];\n    }\n\n    static _derive_ed25519(ked: Dict<any>): [Uint8Array, string] {\n        let verfer;\n        const keys = ked['k'];\n        if (keys.length != 1) {\n            throw new Error(\n                `Basic derivation needs at most 1 key got ${keys.length} keys instead`\n            );\n        }\n\n        try {\n            verfer = new Verfer({ qb64: keys[0] });\n        } catch (e) {\n            throw new Error(`Error extracting public key = ${e}`);\n        }\n\n        if (verfer.code in [MtrDex.Ed25519]) {\n            throw new Error(`Mismatch derivation code = ${verfer.code}`);\n        }\n\n        return [verfer.raw, verfer.code];\n    }\n\n    static _derive_blake3_256(ked: Dict<any>): [Uint8Array, string] {\n        const kd = ked;\n        const ilk = ked['t'];\n        if (![Ilks.icp, Ilks.dip, Ilks.vcp, Ilks.dip].includes(ilk)) {\n            throw new Error(`Invalid ilk = ${ilk} to derive pre.`);\n        }\n\n        kd['i'] = ''.padStart(Matter.Sizes.get(MtrDex.Blake3_256)!.fs!, Dummy);\n        kd['d'] = ked['i'];\n        const [raw] = sizeify(ked);\n        const dig = Buffer.from(\n            blake3.create({ dkLen: 32 }).update(raw).digest()\n        );\n        return [dig, MtrDex.Blake3_256];\n    }\n\n    _verify_ed25519N(\n        ked: Dict<any>,\n        pre: string,\n        prefixed: boolean = false\n    ): boolean {\n        try {\n            const keys = ked['k'];\n            if (keys.length != 1) {\n                return false;\n            }\n\n            if (keys[0] != pre) {\n                return false;\n            }\n\n            if (prefixed && ked['i'] != pre) {\n                return false;\n            }\n\n            const next = 'n' in ked ? ked['n'] : [];\n            if (next.length > 0) {\n                // must be empty\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    _verify_ed25519(\n        ked: Dict<any>,\n        pre: string,\n        prefixed: boolean = false\n    ): boolean {\n        try {\n            const keys = ked['k'];\n            if (keys.length != 1) {\n                return false;\n            }\n\n            if (keys[0] != pre) {\n                return false;\n            }\n\n            if (prefixed && ked['i'] != pre) {\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    _verify_blake3_256(\n        ked: Dict<any>,\n        pre: string,\n        prefixed: boolean = false\n    ): boolean {\n        try {\n            const [raw] = Prefixer._derive_blake3_256(ked);\n            const crymat = new Matter({ raw: raw, code: MtrDex.Blake3_256 });\n            if (crymat.qb64 != pre) {\n                return false;\n            }\n\n            if (prefixed && ked['i'] != pre) {\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }\n}\n", "import { DigiDex, Matter, MatterArgs, MtrDex } from './matter';\nimport { deversify, Dict, Serials } from './core';\nimport { EmptyMaterialError } from './kering';\nimport { dumps, sizeify } from './serder';\nimport { Buffer } from 'buffer';\nimport { blake3 } from '@noble/hashes/blake3';\n\nconst Dummy = '#';\n\nexport enum Ids {\n    d = 'd',\n}\n\nclass Digestage {\n    public klas: any = undefined;\n    public size: number | undefined = 0;\n    public length: number | undefined = 0;\n    constructor(klas: any, size?: number, length?: number) {\n        this.klas = klas;\n        this.size = size;\n        this.length = length;\n    }\n}\n\nexport class Saider extends Matter {\n    static Digests = new Map<string, Digestage>([\n        [\n            MtrDex.Blake3_256,\n            new Digestage(Saider._derive_blake3_256, undefined, undefined),\n        ],\n    ]);\n\n    constructor(\n        { raw, code, qb64b, qb64, qb2 }: MatterArgs,\n        sad?: Dict<any>,\n        kind?: Serials,\n        label: string = Ids.d\n    ) {\n        try {\n            super({ raw, code, qb64b, qb64, qb2 });\n        } catch (e) {\n            if (e instanceof EmptyMaterialError) {\n                if (sad == undefined || !(label in sad)) {\n                    throw e;\n                }\n\n                if (code == undefined) {\n                    if (sad[label] != '') {\n                        super({ qb64: sad[label], code: code });\n                        code = this.code;\n                    } else {\n                        code = MtrDex.Blake3_256;\n                    }\n                }\n\n                if (!DigiDex.has(code)) {\n                    throw new Error(`Unsupported digest code = ${code}`);\n                }\n\n                [raw] = Saider._derive({ ...sad }, code, kind, label);\n                super({ raw: raw, code: code });\n            } else {\n                throw e;\n            }\n        }\n\n        if (!this.digestive) {\n            throw new Error(`Unsupported digest code = ${this.code}.`);\n        }\n    }\n\n    static _derive_blake3_256(\n        ser: Uint8Array,\n        _digest_size: number,\n        _length: number\n    ) {\n        return Buffer.from(blake3.create({ dkLen: 32 }).update(ser).digest());\n    }\n\n    private static _derive(\n        sad: Dict<any>,\n        code: string,\n        kind: Serials | undefined,\n        label: string\n    ): [Uint8Array, Dict<any>] {\n        if (!DigiDex.has(code) || !Saider.Digests.has(code)) {\n            throw new Error(`Unsupported digest code = ${code}.`);\n        }\n\n        sad = { ...sad };\n        sad[label] = ''.padStart(Matter.Sizes.get(code)!.fs!, Dummy);\n        if ('v' in sad) {\n            [, , kind, sad] = sizeify(sad, kind);\n        }\n\n        const ser = { ...sad };\n\n        const digestage = Saider.Digests.get(code);\n\n        const cpa = Saider._serialze(ser, kind);\n        const args: any[] = [];\n        if (digestage!.size != undefined) {\n            args.push(digestage!.size);\n        }\n\n        if (digestage!.length != undefined) {\n            args.push(digestage!.length);\n        }\n\n        return [digestage!.klas(cpa, ...args), sad];\n    }\n\n    public derive(\n        sad: Dict<any>,\n        code: string,\n        kind: Serials | undefined,\n        label: string\n    ): [Uint8Array, Dict<any>] {\n        code = code != undefined ? code : this.code;\n        return Saider._derive(sad, code, kind, label);\n    }\n\n    public verify(\n        sad: Dict<any>,\n        prefixed: boolean = false,\n        versioned: boolean = false,\n        kind?: Serials,\n        label: string = Ids.d\n    ): boolean {\n        try {\n            const [raw, dsad] = Saider._derive(sad, this.code, kind, label);\n            const saider = new Saider({ raw: raw, code: this.code });\n            if (this.qb64 != saider.qb64) {\n                return false;\n            }\n\n            if ('v' in sad && versioned) {\n                if (sad['v'] != dsad['v']) {\n                    return false;\n                }\n            }\n\n            if (prefixed && sad[label] != this.qb64) {\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static _serialze(sad: Dict<any>, kind?: Serials): string {\n        let knd = Serials.JSON;\n        if ('v' in sad) {\n            [, knd] = deversify(sad['v']);\n        }\n\n        if (kind == undefined) {\n            kind = knd;\n        }\n\n        return dumps(sad, kind);\n    }\n\n    public static saidify(\n        sad: Dict<any>,\n        code: string = MtrDex.Blake3_256,\n        kind: Serials = Serials.JSON,\n        label: string = Ids.d\n    ): [Saider, Dict<any>] {\n        if (!(label in sad)) {\n            throw new Error(`Missing id field labeled=${label} in sad.`);\n        }\n        let raw;\n        [raw, sad] = Saider._derive(sad, code, kind, label);\n        const saider = new Saider(\n            { raw: raw, code: code },\n            undefined,\n            kind,\n            label\n        );\n        sad[label] = saider.qb64;\n        return [saider, sad];\n    }\n}\n", "import { Counter, CtrDex } from './counter';\nimport { Seqner } from './seqner';\nimport { Prefixer } from './prefixer';\nimport { Saider } from './saider';\nimport { Serder } from './serder';\nimport { b } from './core';\n\nexport function pad(n: any, width = 3, z = 0) {\n    return (String(z).repeat(width) + String(n)).slice(String(n).length);\n}\n\n/**\n * @description  Returns list of depth first recursively extracted values from elements of\n    key event dict ked whose flabels are in lables list\n\n * @param {*} ked  ked is key event dict\n * @param {*} labels    labels is list of element labels in ked from which to extract values\n */\nexport function extractValues(ked: any, labels: any) {\n    let values = [];\n    for (const label of labels) {\n        values = extractElementValues(ked[label], values);\n    }\n\n    return values;\n}\n\nexport function arrayEquals(ar1: Uint8Array, ar2: Uint8Array) {\n    return (\n        ar1.length === ar2.length &&\n        ar1.every((val, index) => val === ar2[index])\n    );\n}\n\n/**\n * @description   Recusive depth first search that recursively extracts value(s) from element\n    and appends to values list\n    Assumes that extracted values are str\n\n * @param {*} element\n * @param {*} values\n */\n\nfunction extractElementValues(element: any, values: any) {\n    let data = [];\n\n    try {\n        if (element instanceof Array && !(typeof element == 'string')) {\n            for (const k in element) extractElementValues(element[k], values);\n        } else if (typeof element == 'string') {\n            values.push(element);\n        }\n        data = values;\n    } catch (error) {\n        throw new Error(error as string);\n    }\n\n    return data;\n}\n\n/**\n * @description Returns True if obj is non-string iterable, False otherwise\n\n * @param {*} obj\n */\n\n// function nonStringIterable(obj) {\n//     obj instanceof (String)\n//     return  instanceof(obj, (str, bytes)) && instanceof(obj, Iterable))\n// }\n\nexport function nowUTC(): Date {\n    return new Date();\n}\n\nexport function range(start: number, stop: number, step: number) {\n    if (typeof stop == 'undefined') {\n        // one param defined\n        stop = start;\n        start = 0;\n    }\n\n    if (typeof step == 'undefined') {\n        step = 1;\n    }\n\n    if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n        return [];\n    }\n\n    const result = new Array<number>();\n    for (let i: number = start; step > 0 ? i < stop : i > stop; i += step) {\n        result.push(i);\n    }\n\n    return result;\n}\n\nexport function intToBytes(value: number, length: number): Uint8Array {\n    const byteArray = new Uint8Array(length); // Assuming a 4-byte integer (32 bits)\n\n    for (let index = byteArray.length - 1; index >= 0; index--) {\n        const byte = value & 0xff;\n        byteArray[index] = byte;\n        value = (value - byte) / 256;\n    }\n    return byteArray;\n}\n\nexport function bytesToInt(ar: Uint8Array): number {\n    let value = 0;\n    for (let i = 0; i < ar.length; i++) {\n        value = value * 256 + ar[i];\n    }\n    return value;\n}\n\nexport function serializeACDCAttachment(anc: Serder): Uint8Array {\n    const prefixer = new Prefixer({ qb64: anc.pre });\n    const seqner = new Seqner({ sn: anc.sn });\n    const saider = new Saider({ qb64: anc.ked['d'] });\n    const craw = new Uint8Array();\n    const ctr = new Counter({ code: CtrDex.SealSourceTriples, count: 1 }).qb64b;\n    const prefix = prefixer.qb64b;\n    const seq = seqner.qb64b;\n    const said = saider.qb64b;\n    const newCraw = new Uint8Array(\n        craw.length + ctr.length + prefix.length + seq.length + said.length\n    );\n    newCraw.set(craw);\n    newCraw.set(ctr, craw.length);\n    newCraw.set(prefix, craw.length + ctr.length);\n    newCraw.set(seq, craw.length + ctr.length + prefix.length);\n    newCraw.set(said, craw.length + ctr.length + prefix.length + seq.length);\n    return newCraw;\n}\n\nexport function serializeIssExnAttachment(anc: Serder): Uint8Array {\n    const seqner = new Seqner({ sn: anc.sn });\n    const ancSaider = new Saider({ qb64: anc.ked['d'] });\n    const coupleArray = new Uint8Array(\n        seqner.qb64b.length + ancSaider.qb64b.length\n    );\n    coupleArray.set(seqner.qb64b);\n    coupleArray.set(ancSaider.qb64b, seqner.qb64b.length);\n    const counter = new Counter({\n        code: CtrDex.SealSourceCouples,\n        count: 1,\n    });\n    const counterQb64b = counter.qb64b;\n    const atc = new Uint8Array(counter.qb64b.length + coupleArray.length);\n    atc.set(counterQb64b);\n    atc.set(coupleArray, counterQb64b.length);\n\n    if (atc.length % 4 !== 0) {\n        throw new Error(\n            `Invalid attachments size: ${atc.length}, non-integral quadlets detected.`\n        );\n    }\n    const pcnt = new Counter({\n        code: CtrDex.AttachedMaterialQuadlets,\n        count: Math.floor(atc.length / 4),\n    });\n    const msg = new Uint8Array(pcnt.qb64b.length + atc.length);\n    msg.set(pcnt.qb64b);\n    msg.set(atc, pcnt.qb64b.length);\n\n    return msg;\n}\n", "import { Encrypter } from './encrypter';\nimport { Decrypter } from './decrypter';\nimport { Salter, Tier } from './salter';\nimport { Signer } from './signer';\nimport { Verfer } from './verfer';\nimport { MtrDex } from './matter';\nimport { Diger } from './diger';\nimport { Cigar } from './cigar';\nimport { Siger } from './siger';\nimport { b } from './core';\n\nexport enum Algos {\n    randy = 'randy',\n    salty = 'salty',\n    group = 'group',\n    extern = 'extern',\n}\n\nclass PubLot {\n    public pubs: Array<string> = new Array<string>(); // list qb64 public keys.\n    public ridx: number = 0; //  index of rotation (est event) that uses public key set\n    public kidx: number = 0; //  index of key in sequence of public keys\n    public dt: string = ''; // datetime ISO8601 when key set created\n}\n\nclass PreSit {\n    public old: PubLot = new PubLot(); //previous publot\n    public new: PubLot = new PubLot(); //newly current publot\n    public nxt: PubLot = new PubLot(); //next public publot\n}\n\nclass PrePrm {\n    public pidx: number = 0; // prefix index for this keypair sequence\n    public algo: Algos = Algos.salty; // salty default uses indices and salt to create new key pairs\n    public salt: string = ''; // empty salt  used for salty algo.\n    public stem: string = ''; // default unique path stem for salty algo\n    public tier: string = ''; // security tier for stretch index salty algo\n}\n\nclass PubSet {\n    pubs: Array<string> = new Array<string>(); // list qb64 public keys.\n}\n\nclass PubPath {\n    path: string = '';\n    code: string = '';\n    tier: string = Tier.high;\n    temp: boolean = false;\n}\n\nclass Keys {\n    private readonly _signers: Array<Signer>;\n    private readonly _paths?: Array<string>;\n\n    constructor(signers: Array<Signer>, paths?: Array<string>) {\n        this._signers = signers;\n        if (paths != undefined) {\n            if (signers.length != paths.length) {\n                throw new Error(\n                    'If paths are provided, they must be the same length as signers'\n                );\n            }\n        }\n        this._paths = paths;\n    }\n\n    get paths(): Array<string> | undefined {\n        return this._paths;\n    }\n\n    get signers(): Array<Signer> {\n        return this._signers;\n    }\n}\n\nexport interface Creator {\n    create(\n        codes: Array<string> | undefined,\n        count: number,\n        code: string,\n        transferable: boolean,\n        pidx: number,\n        ridx: number,\n        kidx: number,\n        temp: boolean\n    ): Keys;\n    salt: string;\n    stem: string;\n    tier: Tier;\n}\n\nexport class RandyCreator implements Creator {\n    create(\n        codes: Array<string> | undefined = undefined,\n        count: number = 1,\n        code: string = MtrDex.Ed25519_Seed,\n        transferable: boolean = true\n    ): Keys {\n        const signers = new Array<Signer>();\n        if (codes == undefined) {\n            codes = new Array(count).fill(code);\n        }\n\n        codes.forEach(function (code) {\n            signers.push(\n                new Signer({ code: code, transferable: transferable })\n            );\n        });\n\n        return new Keys(signers);\n    }\n\n    get salt(): string {\n        return '';\n    }\n\n    get stem(): string {\n        return '';\n    }\n\n    get tier(): Tier {\n        return '' as Tier;\n    }\n}\n\nexport class SaltyCreator implements Creator {\n    public salter: Salter;\n    private readonly _stem: string;\n    constructor(\n        salt: string | undefined = undefined,\n        tier: Tier | undefined = undefined,\n        stem: string | undefined = undefined\n    ) {\n        this.salter = new Salter({ qb64: salt, tier: tier });\n        this._stem = stem == undefined ? '' : stem;\n    }\n\n    get salt(): string {\n        return this.salter.qb64;\n    }\n\n    get stem(): string {\n        return this._stem;\n    }\n\n    get tier(): Tier {\n        return this.salter.tier!;\n    }\n\n    create(\n        codes: Array<string> | undefined = undefined,\n        count: number = 1,\n        code: string = MtrDex.Ed25519_Seed,\n        transferable: boolean = true,\n        pidx: number = 0,\n        ridx: number = 0,\n        kidx: number = 0,\n        temp: boolean = false\n    ): Keys {\n        const signers = new Array<Signer>();\n        const paths = new Array<string>();\n\n        if (codes == undefined) {\n            codes = new Array<string>(count).fill(code);\n        }\n\n        codes.forEach((code, idx) => {\n            // Previuos definition of path\n            // let path = this.stem + pidx.toString(16) + ridx.toString(16) + (kidx+idx).toString(16)\n            const path =\n                this.stem == ''\n                    ? pidx.toString(16)\n                    : this.stem + ridx.toString(16) + (kidx + idx).toString(16);\n\n            signers.push(\n                this.salter.signer(code, transferable, path, this.tier, temp)\n            );\n            paths.push(path);\n        });\n\n        return new Keys(signers, paths);\n    }\n}\n\nexport class Creatory {\n    private readonly _make: any;\n    constructor(algo: Algos = Algos.salty) {\n        switch (algo) {\n            case Algos.randy:\n                this._make = this._makeRandy;\n                break;\n            case Algos.salty:\n                this._make = this._makeSalty;\n                break;\n            default:\n                throw new Error(`unsupported algo=${algo}`);\n        }\n    }\n\n    make(...args: any[]): Creator {\n        return this._make(...args);\n    }\n\n    _makeRandy(): Creator {\n        return new RandyCreator();\n    }\n\n    _makeSalty(...args: any[]): Creator {\n        return new SaltyCreator(...args);\n    }\n}\n\nexport function openManager(passcode: string, salt?: string) {\n    if (passcode.length < 21) {\n        throw new Error('Bran (passcode seed material) too short.');\n    }\n\n    const bran = MtrDex.Salt_128 + 'A' + passcode.substring(0, 21); // qb64 salt for seed\n    const signer = new Salter({ qb64: bran }).signer(\n        MtrDex.Ed25519_Seed,\n        false\n    );\n    const seed = signer.qb64;\n    const aeid = signer.verfer.qb64; // lest it remove encryption\n\n    let algo;\n\n    const salter = salt != undefined ? new Salter({ qb64: salt }) : undefined;\n    if (salt != undefined) {\n        algo = Algos.salty;\n    } else {\n        algo = Algos.randy;\n    }\n\n    return new Manager({ seed: seed, aeid: aeid, algo: algo, salter: salter });\n}\n\nexport interface ManagerArgs {\n    ks?: KeyStore | undefined;\n    seed?: string | undefined;\n    aeid?: string | undefined;\n    pidx?: number | undefined;\n    algo?: Algos | undefined;\n    salter?: Salter | undefined;\n    tier?: string | undefined;\n}\n\nexport interface ManagerInceptArgs {\n    icodes?: any | undefined;\n    icount?: number;\n    icode?: string;\n    ncodes?: any | undefined;\n    ncount?: number;\n    ncode?: string;\n    dcode?: string;\n    algo?: Algos | undefined;\n    salt?: string | undefined;\n    stem?: string | undefined;\n    tier?: string | undefined;\n    rooted?: boolean;\n    transferable?: boolean;\n    temp?: boolean;\n}\n\ninterface RotateArgs {\n    pre: string;\n    ncodes?: any | undefined;\n    ncount?: number;\n    ncode?: string;\n    dcode?: string;\n    transferable?: boolean;\n    temp?: boolean;\n    erase?: boolean;\n}\n\ninterface SignArgs {\n    ser: Uint8Array;\n    pubs?: Array<string> | undefined;\n    verfers?: Array<Verfer> | undefined;\n    indexed?: boolean;\n    indices?: Array<number> | undefined;\n    ondices?: Array<number> | undefined;\n}\n\nexport class Manager {\n    private _seed?: string;\n    private _salt?: string;\n    private _encrypter: Encrypter | undefined;\n    private _decrypter: Decrypter | undefined;\n    private readonly _ks: KeyStore;\n\n    constructor({ ks, seed, aeid, pidx, algo, salter, tier }: ManagerArgs) {\n        this._ks = ks == undefined ? new Keeper() : ks;\n        this._seed = seed;\n        this._encrypter = undefined;\n        this._decrypter = undefined;\n\n        aeid = aeid == undefined ? undefined : aeid;\n        pidx = pidx == undefined ? 0 : pidx;\n        algo = algo == undefined ? Algos.salty : algo;\n\n        const salt = salter?.qb64;\n\n        tier = tier == undefined ? Tier.low : tier;\n\n        if (this.pidx == undefined) {\n            this.pidx = pidx;\n        }\n\n        if (this.algo == undefined) {\n            this.algo = algo;\n        }\n\n        if (this.salt == undefined) {\n            this.salt = salt;\n        }\n\n        if (this.tier == undefined) {\n            this.tier = tier;\n        }\n\n        if (this.aeid == undefined) {\n            this.updateAeid(aeid, this._seed);\n        }\n    }\n\n    get ks(): KeyStore {\n        return this._ks;\n    }\n\n    get encrypter(): Encrypter | undefined {\n        return this._encrypter;\n    }\n\n    get decrypter(): Decrypter | undefined {\n        return this._decrypter;\n    }\n\n    get seed(): string | undefined {\n        return this._seed;\n    }\n\n    get aeid(): string | undefined {\n        return this.ks.getGbls('aeid');\n    }\n\n    get pidx(): number | undefined {\n        const pidx = this.ks.getGbls('pidx');\n        if (pidx != undefined) {\n            return parseInt(pidx, 16);\n        }\n        return undefined;\n    }\n\n    set pidx(pidx: number | undefined) {\n        this.ks.pinGbls('pidx', pidx!.toString(16));\n    }\n\n    get salt(): string | undefined {\n        if (this._decrypter == undefined) {\n            return this._salt;\n        } else {\n            const salt = this.ks.getGbls('salt');\n            return this._decrypter.decrypt(b(salt)).qb64;\n        }\n    }\n\n    set salt(salt: string | undefined) {\n        if (this._encrypter == undefined) {\n            this._salt = salt;\n        } else {\n            salt = this._encrypter.encrypt(b(salt)).qb64;\n            this.ks.pinGbls('salt', salt!);\n        }\n    }\n\n    get tier(): string | undefined {\n        return this.ks.getGbls('tier');\n    }\n\n    set tier(tier: string | undefined) {\n        this.ks.pinGbls('tier', tier!);\n    }\n\n    get algo(): Algos | undefined {\n        const a = this.ks.getGbls('algo');\n        const ta = a as keyof typeof Algos;\n        return Algos[ta];\n    }\n\n    set algo(algo: Algos | undefined) {\n        this.ks.pinGbls('algo', algo! as string);\n    }\n\n    private updateAeid(aeid: string | undefined, seed?: string) {\n        if (this.aeid != undefined) {\n            const seed = b(this._seed);\n            if (this._seed == undefined || !this._encrypter?.verifySeed(seed)) {\n                throw new Error(`Last seed missing or provided last seed \"\n                                       \"not associated with last aeid=${this.aeid}.`);\n            }\n        }\n\n        if (aeid != '' && aeid != undefined) {\n            if (aeid != this.aeid) {\n                this._encrypter = new Encrypter({}, b(aeid));\n                if (seed == undefined || !this._encrypter.verifySeed(b(seed))) {\n                    throw new Error(`Seed missing or provided seed not associated\"\n                                           \"  with provided aeid=${aeid}.`);\n                }\n            }\n        } else if (this.algo == Algos.randy) {\n            // Unlike KERIpy, we don't support unencrypted secrets\n            throw new Error(\n                'Invalid Manager configuration, encryption must be used with Randy key creation.'\n            );\n        } else {\n            this._encrypter = undefined;\n        }\n\n        const salt = this.salt;\n        if (salt != undefined) {\n            this.salt = salt;\n        }\n\n        if (this._decrypter != undefined) {\n            for (const [keys, data] of this.ks.prmsElements()) {\n                if (data.salt != undefined) {\n                    const salter = this._decrypter.decrypt(b(data.salt));\n                    data.salt =\n                        this._encrypter == undefined\n                            ? salter.qb64\n                            : this._encrypter.encrypt(null, salter);\n                    this.ks.pinPrms(keys, data);\n                }\n            }\n\n            for (const [pubKey, signer] of this.ks.prisElements(\n                this._decrypter\n            )) {\n                this.ks.pinPris(pubKey, signer, this._encrypter!);\n            }\n        }\n\n        this.ks.pinGbls('aeid', aeid!); // set aeid in db\n        this._seed = seed; // set .seed in memory\n\n        // update .decrypter\n        this._decrypter =\n            seed != undefined ? new Decrypter({}, b(seed)) : undefined;\n    }\n\n    incept({\n        icodes = undefined,\n        icount = 1,\n        icode = MtrDex.Ed25519_Seed,\n        ncodes = undefined,\n        ncount = 1,\n        ncode = MtrDex.Ed25519_Seed,\n        dcode = MtrDex.Blake3_256,\n        algo = undefined,\n        salt = undefined,\n        stem = undefined,\n        tier = undefined,\n        rooted = true,\n        transferable = true,\n        temp = false,\n    }: ManagerInceptArgs): [Array<Verfer>, Array<Diger>] {\n        if (rooted && algo == undefined) {\n            algo = this.algo;\n        }\n        if (rooted && salt == undefined) {\n            salt = this.salt;\n        }\n        if (rooted && tier == undefined) {\n            tier = this.tier;\n        }\n\n        const pidx = this.pidx!;\n        const ridx = 0;\n        const kidx = 0;\n\n        const creator = new Creatory(algo).make(salt, tier, stem);\n\n        if (icodes == undefined) {\n            if (icount < 0) {\n                throw new Error(`Invalid icount=${icount} must be >= 0.`);\n            }\n\n            icodes = new Array<string>(icount).fill(icode);\n        }\n\n        const ikeys = creator.create(\n            icodes,\n            0,\n            MtrDex.Ed25519_Seed,\n            transferable,\n            pidx,\n            ridx,\n            kidx,\n            temp\n        );\n        const verfers = Array.from(\n            ikeys.signers,\n            (signer: Signer) => signer.verfer\n        );\n\n        if (ncodes == undefined) {\n            if (ncount < 0) {\n                throw new Error(`Invalid ncount=${ncount} must be >= 0.`);\n            }\n\n            ncodes = new Array<string>(ncount).fill(ncode);\n        }\n\n        const nkeys = creator.create(\n            ncodes,\n            0,\n            MtrDex.Ed25519_Seed,\n            transferable,\n            pidx,\n            ridx + 1,\n            kidx + icodes.length,\n            temp\n        );\n\n        const digers = Array.from(\n            nkeys.signers,\n            (signer: Signer) => new Diger({ code: dcode }, signer.verfer.qb64b)\n        );\n\n        const pp = new PrePrm();\n        pp.pidx = pidx!;\n        pp.algo = algo!;\n        pp.salt =\n            creator.salt.length == 0 || this.encrypter == undefined\n                ? ''\n                : this.encrypter.encrypt(b(creator.salt)).qb64;\n        pp.stem = creator.stem;\n        pp.tier = creator.tier;\n\n        const dt = new Date().toString();\n        const nw = new PubLot();\n        nw.pubs = Array.from(verfers, (verfer: Verfer) => verfer.qb64);\n        nw.ridx = ridx;\n        nw.kidx = kidx;\n        nw.dt = dt;\n\n        const nt = new PubLot();\n        nt.pubs = Array.from(\n            nkeys.signers,\n            (signer: Signer) => signer.verfer.qb64\n        );\n        nt.ridx = ridx + 1;\n        nt.kidx = kidx + icodes.length;\n        nt.dt = dt;\n\n        const ps = new PreSit();\n        ps.new = nw;\n        ps.nxt = nt;\n\n        const pre = verfers[0].qb64;\n        if (!this.ks.putPres(pre, verfers[0].qb64b)) {\n            throw new Error(`Already incepted pre=${pre}.`);\n        }\n\n        if (!this.ks.putPrms(pre, pp)) {\n            throw new Error(`Already incepted prm for pre=${pre}.`);\n        }\n\n        this.pidx = pidx! + 1;\n\n        if (!this.ks.putSits(pre, ps)) {\n            throw new Error(`Already incepted sit for pre=${pre}.`);\n        }\n\n        if (this.encrypter != undefined) {\n            // Only store encrypted keys if we have an encrypter, otherwise regenerate\n            ikeys.signers.forEach((signer: Signer) => {\n                this.ks.putPris(signer.verfer.qb64, signer, this.encrypter!);\n            });\n\n            nkeys.signers.forEach((signer: Signer) => {\n                this.ks.putPris(signer.verfer.qb64, signer, this.encrypter!);\n            });\n        } else if (\n            this._encrypter == undefined &&\n            ikeys.paths != undefined &&\n            nkeys.paths != undefined\n        ) {\n            ikeys.paths.forEach((path: string, idx: number) => {\n                const signer = ikeys.signers[idx];\n                const ppt = new PubPath();\n                ppt.path = path;\n                ppt.code = icodes[idx];\n                ppt.tier = pp.tier;\n                ppt.temp = temp;\n                this.ks.putPths(signer.verfer.qb64, ppt);\n            });\n            nkeys.paths.forEach((path: string, idx: number) => {\n                const signer = nkeys.signers[idx];\n                const ppt = new PubPath();\n                ppt.path = path;\n                ppt.code = ncodes[idx];\n                ppt.tier = pp.tier;\n                ppt.temp = temp;\n                this.ks.putPths(signer.verfer.qb64, ppt);\n            });\n        } else {\n            throw new Error(\n                'invalid configuration, randy keys without encryption'\n            );\n        }\n\n        const pubSet = new PubSet();\n        pubSet.pubs = ps.new.pubs;\n        this.ks.putPubs(riKey(pre, ridx), pubSet);\n\n        const nxtPubSet = new PubSet();\n        nxtPubSet.pubs = ps.nxt.pubs;\n        this.ks.putPubs(riKey(pre, ridx + 1), nxtPubSet);\n\n        return [verfers, digers];\n    }\n\n    move(old: string, gnu: string) {\n        if (old == gnu) {\n            return;\n        }\n\n        if (this.ks.getPres(old) == undefined) {\n            throw new Error(`Nonexistent old pre=${old}, nothing to assign.`);\n        }\n\n        if (this.ks.getPres(gnu) != undefined) {\n            throw new Error(`Preexistent new pre=${gnu} may not clobber.`);\n        }\n\n        const oldprm = this.ks.getPrms(old);\n        if (oldprm == undefined) {\n            throw new Error(\n                `Nonexistent old prm for pre=${old}, nothing to move.`\n            );\n        }\n\n        if (this.ks.getPrms(gnu) != undefined) {\n            throw new Error(\n                `Preexistent new prm for pre=${gnu} may not clobber.`\n            );\n        }\n\n        const oldsit = this.ks.getSits(old);\n        if (oldsit == undefined) {\n            throw new Error(\n                `Nonexistent old sit for pre=${old}, nothing to move.`\n            );\n        }\n\n        if (this.ks.getSits(gnu) != undefined) {\n            throw new Error(\n                `Preexistent new sit for pre=${gnu} may not clobber.`\n            );\n        }\n\n        if (!this.ks.putPrms(gnu, oldprm)) {\n            throw new Error(\n                `Failed moving prm from old pre=${old} to new pre=${gnu}.`\n            );\n        } else {\n            this.ks.remPrms(old);\n        }\n\n        if (!this.ks.putSits(gnu, oldsit)) {\n            throw new Error(\n                `Failed moving sit from old pre=${old} to new pre=${gnu}.`\n            );\n        } else {\n            this.ks.remSits(old);\n        }\n\n        let i = 0;\n        while (true) {\n            const pl = this.ks.getPubs(riKey(old, i));\n            if (pl == undefined) {\n                break;\n            }\n\n            if (!this.ks.putPubs(riKey(gnu, i), pl)) {\n                throw new Error(\n                    `Failed moving pubs at pre=${old} ri=${i} to new pre=${gnu}`\n                );\n            }\n            i = i + 1;\n        }\n\n        if (!this.ks.pinPres(old, b(gnu))) {\n            throw new Error(\n                `Failed assiging new pre=${gnu} to old pre=${old}.`\n            );\n        }\n\n        if (!this.ks.putPres(gnu, b(gnu))) {\n            throw new Error(`Failed assiging new pre=${gnu}.`);\n        }\n    }\n\n    rotate({\n        pre,\n        ncodes = undefined,\n        ncount = 1,\n        ncode = MtrDex.Ed25519_Seed,\n        dcode = MtrDex.Blake3_256,\n        transferable = true,\n        temp = false,\n        erase = true,\n    }: RotateArgs): [Array<Verfer>, Array<Diger>] {\n        const pp = this.ks.getPrms(pre);\n        if (pp == undefined) {\n            throw new Error(`Attempt to rotate nonexistent pre=${pre}.`);\n        }\n\n        const ps = this.ks.getSits(pre);\n        if (ps == undefined) {\n            throw new Error(`Attempt to rotate nonexistent pre=${pre}.`);\n        }\n\n        if (ps.nxt.pubs == undefined || ps.nxt.pubs.length == 0) {\n            throw new Error(`Attempt to rotate nontransferable pre=${pre}.`);\n        }\n\n        const old = ps.old;\n        ps.old = ps.new;\n        ps.new = ps.nxt;\n\n        if (this.aeid != undefined && this.decrypter == undefined) {\n            throw new Error(\n                'Unauthorized decryption attempt.  Aeid but no decrypter.'\n            );\n        }\n\n        const verfers = new Array<Verfer>();\n        ps.new.pubs.forEach((pub) => {\n            if (this.decrypter != undefined) {\n                const signer = this.ks.getPris(pub, this.decrypter);\n                if (signer == undefined) {\n                    throw new Error(`Missing prikey in db for pubkey=${pub}`);\n                }\n                verfers.push(signer.verfer);\n            } else {\n                // Should we regenerate from salt here since this.decryptor is undefined\n                verfers.push(new Verfer({ qb64: pub }));\n            }\n        });\n\n        let salt = pp.salt;\n        if (salt != undefined && salt != '') {\n            // If you provded a Salt for an AID but don't have encryption, pitch a fit\n            if (this.decrypter == undefined) {\n                throw new Error(\n                    'Invalid configuration: AID salt with no encryption'\n                );\n            }\n            salt = this.decrypter.decrypt(b(salt)).qb64;\n        } else {\n            salt = this.salt!;\n        }\n\n        const creator = new Creatory(pp.algo).make(salt, pp.tier, pp.stem);\n\n        if (ncodes == undefined) {\n            if (ncount < 0) {\n                throw new Error(`Invalid count=${ncount} must be >= 0`);\n            }\n            ncodes = new Array<string>(ncount).fill(ncode);\n        }\n\n        const pidx = pp.pidx;\n        const ridx = ps.new.ridx + 1;\n        const kidx = ps.nxt.kidx + ps.new.pubs.length;\n\n        const keys = creator.create(\n            ncodes,\n            0,\n            '',\n            transferable,\n            pidx,\n            ridx,\n            kidx,\n            temp\n        );\n        const digers = Array.from(\n            keys.signers,\n            (signer: Signer) => new Diger({ code: dcode }, signer.verfer.qb64b)\n        );\n\n        const dt = new Date().toString();\n        ps.nxt = new PubLot();\n        ps.nxt.pubs = Array.from(\n            keys.signers,\n            (signer: Signer) => signer.verfer.qb64\n        );\n        ps.nxt.ridx = ridx;\n        ps.nxt.kidx = kidx;\n        ps.nxt.dt = dt;\n\n        if (!this.ks.pinSits(pre, ps)) {\n            throw new Error(`Problem updating pubsit db for pre=${pre}.`);\n        }\n\n        if (this.encrypter != undefined) {\n            // Only store encrypted keys if we have an encrypter, otherwise regenerate\n            keys.signers.forEach((signer: Signer) => {\n                this.ks.putPris(signer.verfer.qb64, signer, this.encrypter!);\n            });\n        } else if (this._encrypter == undefined && keys.paths != undefined) {\n            keys.paths.forEach((path: string, idx: number) => {\n                const signer = keys.signers[idx];\n                const ppt = new PubPath();\n                ppt.path = path;\n                ppt.tier = pp!.tier;\n                ppt.temp = temp;\n                this.ks.putPths(signer.verfer.qb64, ppt);\n            });\n        } else {\n            throw new Error(\n                'invalid configuration, randy keys without encryption'\n            );\n        }\n\n        const newPs = new PubSet();\n        newPs.pubs = ps.nxt.pubs;\n        this.ks.putPubs(riKey(pre, ps.nxt.ridx), newPs);\n\n        if (erase) {\n            old.pubs.forEach((pub) => {\n                this.ks.remPris(pub);\n            });\n        }\n\n        return [verfers, digers];\n    }\n\n    sign({\n        ser,\n        pubs = undefined,\n        verfers = undefined,\n        indexed = true,\n        indices = undefined,\n        ondices = undefined,\n    }: SignArgs) {\n        const signers = new Array<Signer>();\n\n        if (pubs == undefined && verfers == undefined) {\n            throw new Error('pubs or verfers required');\n        }\n\n        if (pubs != undefined) {\n            if (this.aeid != undefined && this.decrypter == undefined) {\n                throw new Error(\n                    'Unauthorized decryption attempt.  Aeid but no decrypter.'\n                );\n            }\n\n            pubs.forEach((pub) => {\n                //If no decrypter then get SaltyState and regenerate prikey\n                if (this.decrypter != undefined) {\n                    const signer = this.ks.getPris(pub, this.decrypter);\n                    if (signer == undefined) {\n                        throw new Error(\n                            `Missing prikey in db for pubkey=${pub}`\n                        );\n                    }\n                    signers.push(signer);\n                } else {\n                    const verfer = new Verfer({ qb64: pub });\n                    const ppt = this.ks.getPths(pub);\n                    if (ppt == undefined) {\n                        throw new Error(\n                            `Missing prikey in db for pubkey=${pub}`\n                        );\n                    }\n                    const salter = new Salter({ qb64: this.salt });\n                    signers.push(\n                        salter.signer(\n                            ppt.code,\n                            verfer.transferable,\n                            ppt.path,\n                            ppt.tier as Tier,\n                            ppt.temp\n                        )\n                    );\n                }\n            });\n        } else {\n            verfers!.forEach((verfer: Verfer) => {\n                if (this.decrypter != undefined) {\n                    const signer = this.ks.getPris(verfer.qb64, this.decrypter);\n                    if (signer == undefined) {\n                        throw new Error(\n                            `Missing prikey in db for pubkey=${verfer.qb64}`\n                        );\n                    }\n                    signers.push(signer);\n                } else {\n                    const ppt = this.ks.getPths(verfer.qb64);\n                    if (ppt == undefined) {\n                        throw new Error(\n                            `Missing prikey in db for pubkey=${verfer.qb64}`\n                        );\n                    }\n                    const salter = new Salter({ qb64: this.salt });\n                    signers.push(\n                        salter.signer(\n                            ppt.code,\n                            verfer.transferable,\n                            ppt.path,\n                            ppt.tier as Tier,\n                            ppt.temp\n                        )\n                    );\n                }\n            });\n        }\n\n        if (indices != undefined && indices.length != signers.length) {\n            throw new Error(\n                `Mismatch indices length=${indices.length} and resultant signers length=${signers.length}`\n            );\n        }\n\n        if (ondices != undefined && ondices.length != signers.length) {\n            throw new Error(\n                `Mismatch ondices length=${ondices.length} and resultant signers length=${signers.length}`\n            );\n        }\n\n        if (indexed) {\n            const sigers = new Array<Siger>();\n            signers.forEach((signer, idx) => {\n                let i;\n                if (indices != undefined) {\n                    i = indices[idx];\n                    if (i < 0) {\n                        throw new Error(\n                            `Invalid signing index = ${i}, not whole number.`\n                        );\n                    }\n                } else {\n                    i = idx;\n                }\n\n                let o;\n                if (ondices != undefined) {\n                    o = ondices[idx];\n                    if (o <= 0) {\n                        throw new Error(\n                            `Invalid other signing index = {o}, not None or not whole number.`\n                        );\n                    }\n                } else {\n                    o = i;\n                }\n\n                const only = o == undefined;\n                sigers.push(signer.sign(ser, i, only, o) as Siger);\n            });\n            return sigers;\n        } else {\n            const cigars = new Array<Cigar>();\n            signers.forEach((signer: Signer) => {\n                cigars.push(signer.sign(ser) as Cigar);\n            });\n\n            return cigars;\n        }\n    }\n}\n\nexport function riKey(pre: string, ridx: number) {\n    return pre + '.' + ridx.toString(16).padStart(32, '0');\n}\n\nexport interface KeyStore {\n    getGbls(key: string): string | undefined;\n    pinGbls(key: string, val: string): void;\n\n    prmsElements(): Array<[string, PrePrm]>;\n    getPrms(keys: string): PrePrm | undefined;\n    pinPrms(keys: string, data: PrePrm): void;\n    putPrms(keys: string, data: PrePrm): boolean;\n    remPrms(keys: string): boolean;\n\n    prisElements(decrypter: Decrypter): Array<[string, Signer]>;\n    getPris(keys: string, decrypter: Decrypter): Signer | undefined;\n    pinPris(keys: string, data: Signer, encrypter: Encrypter): void;\n    putPris(pubKey: string, signer: Signer, encrypter: Encrypter): boolean;\n    remPris(pubKey: string): void;\n\n    getPths(pubKey: string): PubPath | undefined;\n    putPths(pubKey: string, val: PubPath): boolean;\n    pinPths(pubKey: string, val: PubPath): boolean;\n\n    getPres(pre: string): Uint8Array | undefined;\n    putPres(pre: string, val: Uint8Array): boolean;\n    pinPres(pre: string, val: Uint8Array): boolean;\n\n    getSits(keys: string): PreSit | undefined;\n    putSits(pre: string, val: PreSit): boolean;\n    pinSits(pre: string, val: PreSit): boolean;\n    remSits(keys: string): boolean;\n\n    getPubs(keys: string): PubSet | undefined;\n    putPubs(keys: string, data: PubSet): boolean;\n}\n\n/*\n     In memory test implementation of Keeper key store\n*/\n\nclass Keeper implements KeyStore {\n    private readonly _gbls: Map<string, string>;\n    private readonly _pris: Map<string, Uint8Array>;\n    private readonly _pths: Map<string, PubPath>;\n    private readonly _pres: Map<string, Uint8Array>;\n    private readonly _prms: Map<string, PrePrm>;\n    private readonly _sits: Map<string, PreSit>;\n    private readonly _pubs: Map<string, PubSet>;\n\n    constructor() {\n        this._gbls = new Map<string, string>();\n        this._pris = new Map<string, Uint8Array>();\n        this._pths = new Map<string, PubPath>();\n        this._pres = new Map<string, Uint8Array>();\n        this._prms = new Map<string, PrePrm>();\n        this._sits = new Map<string, PreSit>();\n        this._pubs = new Map<string, PubSet>();\n    }\n\n    getGbls(key: string): string | undefined {\n        return this._gbls.get(key);\n    }\n\n    pinGbls(key: string, val: string): void {\n        this._gbls.set(key, val);\n    }\n\n    prmsElements(): Array<[string, PrePrm]> {\n        const out = new Array<[string, PrePrm]>();\n        this._prms.forEach((value, key) => {\n            out.push([key, value]);\n        });\n\n        return out;\n    }\n\n    getPrms(keys: string): PrePrm | undefined {\n        return this._prms.get(keys);\n    }\n\n    pinPrms(keys: string, data: PrePrm): void {\n        this._prms.set(keys, data);\n    }\n\n    putPrms(keys: string, data: PrePrm): boolean {\n        if (this._prms.has(keys)) {\n            return false;\n        }\n        this._prms.set(keys, data);\n        return true;\n    }\n\n    remPrms(keys: string): boolean {\n        return this._prms.delete(keys);\n    }\n\n    prisElements(decrypter: Decrypter): Array<[string, Signer]> {\n        const out = new Array<[string, Signer]>();\n        this._pris.forEach(function (val, pubKey) {\n            const verfer = new Verfer({ qb64: pubKey });\n            const signer = decrypter.decrypt(val, null, verfer.transferable);\n            out.push([pubKey, signer]);\n        });\n        return out;\n    }\n\n    pinPris(pubKey: string, signer: Signer, encrypter: Encrypter): void {\n        const cipher = encrypter.encrypt(null, signer);\n        this._pris.set(pubKey, cipher.qb64b);\n    }\n\n    putPris(pubKey: string, signer: Signer, encrypter: Encrypter): boolean {\n        if (this._pris.has(pubKey)) {\n            return false;\n        }\n        const cipher = encrypter.encrypt(null, signer);\n        this._pris.set(pubKey, cipher.qb64b);\n        return true;\n    }\n\n    getPris(pubKey: string, decrypter: Decrypter): Signer | undefined {\n        const val = this._pris.get(pubKey);\n        if (val == undefined) {\n            return undefined;\n        }\n        const verfer = new Verfer({ qb64: pubKey });\n\n        return decrypter.decrypt(val, null, verfer.transferable);\n    }\n\n    pinPths(pubKey: string, val: PubPath): boolean {\n        this._pths.set(pubKey, val);\n        return true;\n    }\n\n    putPths(pubKey: string, val: PubPath): boolean {\n        if (this._pths.has(pubKey)) {\n            return false;\n        }\n\n        this._pths.set(pubKey, val);\n        return true;\n    }\n\n    getPths(pubKey: string): PubPath | undefined {\n        return this._pths.get(pubKey);\n    }\n\n    remPris(pubKey: string): void {\n        this._pris.delete(pubKey);\n    }\n\n    getPres(pre: string): Uint8Array | undefined {\n        return this._pres.get(pre);\n    }\n\n    pinPres(pre: string, val: Uint8Array): boolean {\n        this._pres.set(pre, val);\n        return true;\n    }\n\n    putPres(pre: string, val: Uint8Array): boolean {\n        if (this._pres.has(pre)) {\n            return false;\n        }\n\n        this._pres.set(pre, val);\n        return true;\n    }\n\n    getSits(keys: string): PreSit | undefined {\n        return this._sits.get(keys);\n    }\n\n    putSits(pre: string, val: PreSit): boolean {\n        if (this._sits.has(pre)) {\n            return false;\n        }\n\n        this._sits.set(pre, val);\n        return true;\n    }\n\n    pinSits(pre: string, val: PreSit): boolean {\n        this._sits.set(pre, val);\n        return true;\n    }\n\n    remSits(keys: string): boolean {\n        return this._sits.delete(keys);\n    }\n\n    getPubs(keys: string): PubSet | undefined {\n        return this._pubs.get(keys);\n    }\n\n    putPubs(keys: string, data: PubSet): boolean {\n        if (this._pubs.has(keys)) {\n            return false;\n        }\n        this._pubs.set(keys, data);\n        return true;\n    }\n}\n", "import { BexDex, Matter, NumDex } from './matter';\nimport { CesrNumber } from './number';\nimport { Fraction, format, sum, fraction } from 'mathjs';\n\nexport class Tholder {\n    private _weighted: boolean = false;\n    private _thold: any = undefined;\n    private _size: number = 0;\n    private _number: CesrNumber | undefined = undefined;\n    private _satisfy: any = undefined;\n\n    // private _bexter: any\n\n    constructor(kargs: { thold?: any; limen?: any; sith?: any }) {\n        if (kargs.thold !== undefined) {\n            this._processThold(kargs.thold);\n        } else if (kargs.limen != undefined) {\n            this._processLimen(kargs.limen);\n        } else if (kargs.sith !== undefined) {\n            this._processSith(kargs.sith);\n        } else {\n            throw new Error('Missing threshold expression');\n        }\n    }\n\n    get weighted(): boolean {\n        return this._weighted;\n    }\n\n    get thold(): any {\n        return this._thold;\n    }\n\n    get size(): number {\n        return this._size;\n    }\n\n    get limen(): any {\n        return this._number?.qb64b;\n    }\n\n    get sith(): string {\n        if (this.weighted) {\n            let sith = this.thold.map((clause: Fraction[]) => {\n                return clause.map((c) => {\n                    if (0 < Number(c) && Number(c) < 1) {\n                        return format(c, { fraction: 'ratio' });\n                    } else {\n                        return format(c, { fraction: 'decimal' });\n                    }\n                });\n            });\n            if (sith.length == 1) {\n                sith = sith[0];\n            }\n\n            return sith;\n        } else {\n            return this.thold.toString(16);\n        }\n    }\n\n    get json(): string {\n        return JSON.stringify(this.sith);\n    }\n\n    get num(): number | undefined {\n        return this._weighted ? undefined : this._thold;\n    }\n\n    private _processThold(thold: number | Array<Array<Fraction>>) {\n        if (typeof thold === 'number') {\n            this._processUnweighted(thold);\n        } else {\n            this._processWeighted(thold);\n        }\n    }\n\n    private _processLimen(limen: string) {\n        const matter = new Matter({ qb64: limen });\n        if (NumDex.has(matter.code)) {\n            const number = new CesrNumber({\n                raw: matter.raw,\n                code: matter.code,\n            });\n            this._processUnweighted(number.num);\n        } else if (BexDex.has(matter.code)) {\n            // TODO: Implement Bexter\n        } else {\n            throw new Error('Invalid code for limen=' + matter.code);\n        }\n    }\n\n    private _processSith(sith: string | number | Array<string>) {\n        if (typeof sith == 'number') {\n            this._processUnweighted(sith);\n        } else if (typeof sith == 'string' && sith.indexOf('[') == -1) {\n            this._processUnweighted(parseInt(sith, 16));\n        } else {\n            let _sith: any = sith;\n            if (typeof sith == 'string') {\n                _sith = JSON.parse(sith);\n            }\n\n            if (_sith.length == 0) {\n                throw new Error('Empty weight list');\n            }\n\n            const mask = _sith.map((x: any) => {\n                return typeof x !== 'string';\n            });\n\n            if (mask.length > 0 && !mask.every((x: boolean) => x)) {\n                _sith = [_sith];\n            }\n\n            for (const c of _sith) {\n                const mask = c.map((x: any) => {\n                    return typeof x === 'string';\n                });\n                if (mask.length > 0 && !mask.every((x: boolean) => x)) {\n                    throw new Error(\n                        'Invalid sith, some weights in clause ' +\n                            mask +\n                            ' are non string'\n                    );\n                }\n            }\n\n            const thold = this._processClauses(_sith);\n            this._processWeighted(thold);\n        }\n    }\n\n    private _processClauses(sith: Array<Array<string>>): Fraction[][] {\n        const thold = new Array<Array<Fraction>>();\n        sith.forEach((clause) => {\n            thold.push(\n                clause.map((w) => {\n                    return this.weight(w);\n                })\n            );\n        });\n        return thold;\n    }\n\n    private _processUnweighted(thold: number) {\n        if (thold < 0) {\n            throw new Error('Non-positive int threshold = {thold}.');\n        }\n        this._thold = thold;\n        this._weighted = false;\n        this._size = this._thold; // used to verify that keys list size is at least size\n        this._satisfy = this._satisfy_numeric;\n        this._number = new CesrNumber({}, thold);\n        // this._bexter = undefined\n    }\n\n    private _processWeighted(thold: Array<Array<Fraction>>) {\n        for (const clause of thold) {\n            if (Number(sum(clause)) < 1) {\n                throw new Error(\n                    'Invalid sith clause: ' +\n                        thold +\n                        'all clause weight sums must be >= 1'\n                );\n            }\n        }\n\n        this._thold = thold;\n        this._weighted = true;\n        this._size = thold.reduce((acc, currentValue) => {\n            return acc + currentValue.length;\n        }, 0);\n        this._satisfy = this._satisfy_weighted;\n        //TODO: created Bexter if needed\n    }\n\n    private weight(w: string): Fraction {\n        return fraction(w);\n    }\n\n    private _satisfy_numeric(indices: any[]) {\n        return this.thold > 0 && indices.length >= this.thold; // at least one\n    }\n\n    private _satisfy_weighted(indices: any) {\n        if (indices.length === 0) {\n            return false;\n        }\n\n        const indexes: Set<number> = new Set(indices.sort());\n        const sats = new Array(indices.length).fill(false);\n        for (const idx of indexes) {\n            sats[idx] = true;\n        }\n        let wio = 0;\n        for (const clause of this.thold) {\n            let cw = 0;\n            for (const w of clause) {\n                if (sats[wio]) {\n                    cw += Number(w);\n                }\n                wio += 1;\n            }\n            if (cw < 1) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public satisfy(indices: any): boolean {\n        return this._satisfy(indices);\n    }\n}\n", "import {\n    b,\n    concat,\n    Dict,\n    Ident,\n    Ilks,\n    Serials,\n    versify,\n    Version,\n    Versionage,\n} from './core';\nimport { Tholder } from './tholder';\nimport { CesrNumber } from './number';\nimport { Prefixer } from './prefixer';\nimport { Serder } from './serder';\nimport { MtrDex, NonTransDex } from './matter';\nimport { Saider } from './saider';\nimport { Siger } from './siger';\nimport { Cigar } from './cigar';\nimport { Counter, CtrDex } from './counter';\nimport { Seqner } from './seqner';\n\nconst MaxIntThold = 2 ** 32 - 1;\n\nexport interface RotateArgs {\n    pre?: string;\n    keys: Array<string>;\n    dig?: string;\n    ilk?: string;\n    sn?: number;\n    isith?: number | string | Array<string>;\n    ndigs?: Array<string>;\n    nsith?: number | string | Array<string>;\n    toad?: number;\n    wits?: Array<string>;\n    cuts?: Array<string>;\n    adds?: Array<string>;\n    cnfg?: Array<string>;\n    data?: Array<object>;\n    version?: Version;\n    kind?: Serials;\n    size?: number;\n    intive?: boolean;\n}\n\nexport function rotate({\n    pre = undefined,\n    keys,\n    dig = undefined,\n    ilk = Ilks.rot,\n    sn = 1,\n    isith = undefined,\n    ndigs = undefined,\n    nsith = undefined,\n    wits = undefined,\n    cuts = undefined,\n    adds = undefined,\n    toad = undefined,\n    data = undefined,\n    version = undefined,\n    kind = undefined,\n    intive = true,\n}: RotateArgs) {\n    const vs = versify(Ident.KERI, version, kind, 0);\n    const _ilk = ilk;\n    if (_ilk != Ilks.rot && _ilk != Ilks.drt) {\n        throw new Error(`Invalid ilk = ${ilk} for rot or drt.`);\n    }\n\n    const sner = new CesrNumber({}, sn);\n    if (sner.num < 1) {\n        throw new Error(`Invalid sn = 0x${sner.numh} for rot or drt.`);\n    }\n    let _isit: number;\n\n    if (isith == undefined) {\n        _isit = Math.max(1, Math.ceil(keys.length / 2));\n    } else {\n        _isit = isith as number;\n    }\n\n    const tholder = new Tholder({ sith: _isit });\n    if (tholder.num != undefined && tholder.num < 1) {\n        throw new Error(`Invalid sith = ${tholder.num} less than 1.`);\n    }\n    if (tholder.size > keys.length) {\n        throw new Error(`Invalid sith = ${tholder.num} for keys = ${keys}`);\n    }\n\n    let _ndigs: Array<string>;\n\n    if (ndigs === undefined) {\n        _ndigs = [];\n    } else {\n        _ndigs = ndigs;\n    }\n\n    let _nsith;\n    if (nsith === undefined) {\n        _nsith = Math.max(1, Math.ceil(_ndigs.length / 2));\n    } else {\n        _nsith = nsith;\n    }\n\n    const ntholder = new Tholder({ sith: _nsith });\n    if (ntholder.num != undefined && ntholder.num < 1) {\n        throw new Error(`Invalid sith = ${ntholder.num} less than 1.`);\n    }\n    if (ntholder.size > _ndigs.length) {\n        throw new Error(`Invalid sith = ${ntholder.num} for ndigs = ${ndigs}`);\n    }\n\n    let _wits: Array<string>;\n    if (wits === undefined) {\n        _wits = [];\n    } else {\n        _wits = wits;\n    }\n    const witset = new Set(_wits);\n    if (witset.size != _wits.length) {\n        throw new Error(`Invalid wits = ${wits}, has duplicates.`);\n    }\n\n    let _cuts: Array<string>;\n    if (cuts === undefined) {\n        _cuts = [];\n    } else {\n        _cuts = cuts;\n    }\n    const cutset = new Set(_cuts);\n    if (cutset.size != _cuts.length) {\n        throw new Error(`Invalid cuts = ${cuts}, has duplicates.`);\n    }\n\n    let _adds: Array<string>;\n    if (adds === undefined) {\n        _adds = [];\n    } else {\n        _adds = adds;\n    }\n    const addset = new Set(_adds);\n\n    //non empty intersection of witset and addset\n    const witaddset = new Set([...witset].filter((x) => addset.has(x)));\n    if (witaddset.size > 0) {\n        throw new Error(\n            `Invalid member combination among wits = ${wits}, and adds = ${adds}.`\n        );\n    }\n\n    // non empty intersection of cutset and addset\n    const cutaddset = new Set([...cutset].filter((x) => addset.has(x)));\n    if (cutaddset.size > 0) {\n        throw new Error(\n            `Invalid member combination among cuts = ${cuts}, and adds = ${adds}.`\n        );\n    }\n\n    const newitsetdiff = new Set(_wits);\n    _cuts.forEach(function (v) {\n        newitsetdiff.delete(v);\n    });\n    const newitset = new Set(\n        (function* () {\n            yield* newitsetdiff;\n            yield* addset;\n        })()\n    );\n\n    if (newitset.size != witset.size - cutset.size + addset.size) {\n        throw new Error(\n            `Invalid member combination among wits = ${wits}, cuts = ${cuts}, and adds = ${adds}.`\n        );\n    }\n\n    let _toad: number;\n\n    if (toad === undefined) {\n        if (newitset.size == 0) {\n            _toad = 0;\n        } else {\n            _toad = ample(newitset.size);\n        }\n    } else {\n        _toad = toad;\n    }\n\n    if (newitset.size > 0) {\n        if (_toad < 1 || _toad > newitset.size) {\n            throw new Error(`Invalid toad = ${_toad} for wit = ${wits}`);\n        }\n    } else {\n        if (_toad != 0) {\n            throw new Error(`Invalid toad = ${_toad} for wit = ${wits}`);\n        }\n    }\n    const _ked = {\n        v: vs,\n        t: _ilk,\n        d: '',\n        i: pre,\n        s: sner.numh,\n        p: dig,\n        kt:\n            tholder.num &&\n            intive &&\n            tholder.num !== undefined &&\n            tholder.num <= MaxIntThold\n                ? tholder.num.toString(16)\n                : tholder.sith,\n        k: keys,\n        nt:\n            ntholder.num &&\n            intive &&\n            ntholder.num !== undefined &&\n            ntholder.num <= MaxIntThold\n                ? ntholder.num.toString(16)\n                : ntholder.sith,\n        n: _ndigs,\n        bt:\n            _toad && intive && _toad !== undefined && _toad <= MaxIntThold\n                ? _toad\n                : _toad.toString(16),\n        br: cuts,\n        ba: adds,\n        a: data != undefined ? data : [],\n    };\n    const [, ked] = Saider.saidify(_ked);\n    return new Serder(ked);\n}\n\nexport function ample(n: number, f?: number, weak = true) {\n    n = Math.max(0, n); // no negatives\n    let f1;\n    if (f == undefined) {\n        f1 = Math.max(1, Math.floor(Math.max(0, n - 1) / 3)); // least floor f subject to n >= 3*f+1\n\n        const f2 = Math.max(1, Math.ceil(Math.max(0, n - 1) / 3)); // most Math.ceil f subject to n >= 3*f+1\n        if (weak) {\n            // try both fs to see which one has lowest m\n            return Math.min(\n                n,\n                Math.ceil((n + f1 + 1) / 2),\n                Math.ceil((n + f2 + 1) / 2)\n            );\n        } else {\n            return Math.min(\n                n,\n                Math.max(0, n - f1, Math.ceil((n + f1 + 1) / 2))\n            );\n        }\n    } else {\n        f = Math.max(0, f);\n        const m1 = Math.ceil((n + f + 1) / 2);\n        const m2 = Math.max(0, n - f);\n        if (m2 < m1 && n > 0) {\n            throw new Error(`Invalid f=${f} is too big for n=${n}.`);\n        }\n        if (weak) {\n            return Math.min(n, m1, m2);\n        } else {\n            return Math.min(n, Math.max(m1, m2));\n        }\n    }\n}\n\nexport interface InceptArgs {\n    keys: Array<string>;\n    isith?: number | string | Array<string>;\n    ndigs?: Array<string>;\n    nsith?: number | string | Array<string>;\n    toad?: number | string;\n    wits?: Array<string>;\n    cnfg?: Array<string>;\n    data?: Array<object>;\n    version?: Version;\n    kind?: Serials;\n    code?: string;\n    intive?: boolean;\n    delpre?: string;\n}\n\nexport function incept({\n    keys,\n    isith,\n    ndigs,\n    nsith,\n    toad,\n    wits,\n    cnfg,\n    data,\n    version = Versionage,\n    kind = Serials.JSON,\n    code,\n    intive = false,\n    delpre,\n}: InceptArgs) {\n    const vs = versify(Ident.KERI, version, kind, 0);\n    const ilk = delpre == undefined ? Ilks.icp : Ilks.dip;\n    const sner = new CesrNumber({}, 0);\n\n    if (isith == undefined) {\n        isith = Math.max(1, Math.ceil(keys.length / 2));\n    }\n\n    const tholder = new Tholder({ sith: isith });\n    if (tholder.num != undefined && tholder.num < 1) {\n        throw new Error(`Invalid sith = ${tholder.num} less than 1.`);\n    }\n    if (tholder.size > keys.length) {\n        throw new Error(`Invalid sith = ${tholder.num} for keys ${keys}`);\n    }\n\n    if (ndigs == undefined) {\n        ndigs = new Array<string>();\n    }\n\n    if (nsith == undefined) {\n        nsith = Math.max(0, Math.ceil(ndigs.length / 2));\n    }\n\n    const ntholder = new Tholder({ sith: nsith });\n    if (ntholder.num != undefined && ntholder.num < 0) {\n        throw new Error(`Invalid nsith = ${ntholder.num} less than 0.`);\n    }\n    if (ntholder.size > keys.length) {\n        throw new Error(`Invalid nsith = ${ntholder.num} for keys ${ndigs}`);\n    }\n\n    wits = wits == undefined ? [] : wits;\n    if (new Set(wits).size != wits.length) {\n        throw new Error(`Invalid wits = ${wits}, has duplicates.`);\n    }\n\n    if (toad == undefined) {\n        if (wits.length == 0) {\n            toad = 0;\n        } else {\n            toad = ample(wits.length);\n        }\n    }\n\n    const toader = new CesrNumber({}, toad);\n    if (wits.length > 0) {\n        if (toader.num < 1 || toader.num > wits.length) {\n            throw new Error(`Invalid toad = ${toader.num} for wits = ${wits}`);\n        }\n    } else {\n        if (toader.num != 0) {\n            throw new Error(`Invalid toad = ${toader.num} for wits = ${wits}`);\n        }\n    }\n\n    cnfg = cnfg == undefined ? new Array<string>() : cnfg;\n    data = data == undefined ? new Array<object>() : data;\n\n    let ked = {\n        v: vs,\n        t: ilk,\n        d: '',\n        i: '',\n        s: sner.numh,\n        kt: intive && tholder.num != undefined ? tholder.num : tholder.sith,\n        k: keys,\n        nt: intive && tholder.num != undefined ? ntholder.num : ntholder.sith,\n        n: ndigs,\n        bt: intive ? toader.num : toader.numh,\n        b: wits,\n        c: cnfg,\n        a: data,\n    } as Dict<any>;\n\n    if (delpre != undefined) {\n        ked['di'] = delpre;\n        if (code == undefined) {\n            code = MtrDex.Blake3_256;\n        }\n    }\n\n    let prefixer;\n    if (delpre == undefined && code == undefined && keys.length == 1) {\n        prefixer = new Prefixer({ qb64: keys[0] });\n        if (prefixer.digestive) {\n            throw new Error(\n                `Invalid code, digestive=${prefixer.code}, must be derived from ked.`\n            );\n        }\n    } else {\n        prefixer = new Prefixer({ code: code }, ked);\n        if (delpre != undefined) {\n            if (!prefixer.digestive) {\n                throw new Error(\n                    `Invalid derivation code = ${prefixer.code} for delegation. Must be digestive`\n                );\n            }\n        }\n    }\n\n    ked['i'] = prefixer.qb64;\n    if (prefixer.digestive) {\n        ked['d'] = prefixer.qb64;\n    } else {\n        [, ked] = Saider.saidify(ked);\n    }\n\n    return new Serder(ked);\n}\n\nexport function messagize(\n    serder: Serder,\n    sigers?: Array<Siger>,\n    seal?: any,\n    wigers?: Array<Cigar>,\n    cigars?: Array<Cigar>,\n    pipelined: boolean = false\n): Uint8Array {\n    let msg = new Uint8Array(b(serder.raw));\n    let atc = new Uint8Array();\n\n    if (sigers == undefined && wigers == undefined && cigars == undefined) {\n        throw new Error(\n            `Missing attached signatures on message = ${serder.ked}.`\n        );\n    }\n\n    if (sigers != undefined) {\n        if (seal != undefined) {\n            if (seal[0] == 'SealEvent') {\n                atc = concat(\n                    atc,\n                    new Counter({ code: CtrDex.TransIdxSigGroups, count: 1 })\n                        .qb64b\n                );\n                atc = concat(atc, new TextEncoder().encode(seal[1].i));\n                atc = concat(\n                    atc,\n                    new Seqner({ sn: parseInt(seal[1].s) }).qb64b\n                );\n                atc = concat(atc, new TextEncoder().encode(seal[1].d));\n            } else if (seal[0] == 'SealLast') {\n                atc = concat(\n                    atc,\n                    new Counter({\n                        code: CtrDex.TransLastIdxSigGroups,\n                        count: 1,\n                    }).qb64b\n                );\n                atc = concat(atc, new TextEncoder().encode(seal[1].i));\n            }\n        }\n\n        atc = concat(\n            atc,\n            new Counter({\n                code: CtrDex.ControllerIdxSigs,\n                count: sigers.length,\n            }).qb64b\n        );\n        sigers.forEach((siger) => {\n            atc = concat(atc, siger.qb64b);\n        });\n    }\n\n    if (wigers != undefined) {\n        atc = concat(\n            atc,\n            new Counter({\n                code: CtrDex.ControllerIdxSigs,\n                count: wigers.length,\n            }).qb64b\n        );\n\n        wigers.forEach((wiger) => {\n            if (wiger.verfer && !(wiger.verfer.code in NonTransDex)) {\n                throw new Error(\n                    `Attempt to use tranferable prefix=${wiger.verfer.qb64} for receipt.`\n                );\n            }\n            atc = concat(atc, wiger.qb64b);\n        });\n    }\n\n    if (cigars != undefined) {\n        atc = concat(\n            atc,\n            new Counter({\n                code: CtrDex.ControllerIdxSigs,\n                count: cigars.length,\n            }).qb64b\n        );\n\n        cigars.forEach((cigar) => {\n            if (cigar.verfer && !(cigar.verfer.code in NonTransDex)) {\n                throw new Error(\n                    `Attempt to use tranferable prefix=${cigar.verfer.qb64} for receipt.`\n                );\n            }\n            atc = concat(atc, cigar.qb64b);\n        });\n    }\n\n    if (pipelined) {\n        if (atc.length % 4 != 0) {\n            throw new Error(\n                `Invalid attachments size=${atc.length}, nonintegral quadlets.`\n            );\n        }\n        msg = concat(\n            msg,\n            new Counter({\n                code: CtrDex.AttachedMaterialQuadlets,\n                count: Math.floor(atc.length / 4),\n            }).qb64b\n        );\n    }\n    msg = concat(msg, atc);\n    return msg;\n}\n\ninterface InteractArgs {\n    pre: string;\n    dig: string;\n    sn: number;\n    data: Array<any>;\n    version: Version | undefined;\n    kind: Serials | undefined;\n}\n\nexport function interact(args: InteractArgs): Serder {\n    let { pre, dig, sn, data, version, kind } = args;\n    const vs = versify(Ident.KERI, version, kind, 0);\n    const ilk = Ilks.ixn;\n    const sner = new CesrNumber({}, sn);\n\n    if (sner.num < 1) {\n        throw new Error(`Invalid sn = 0x${sner.numh} for ixn.`);\n    }\n\n    data = data == undefined ? new Array<any>() : data;\n\n    let ked = {\n        v: vs,\n        t: ilk,\n        d: '',\n        i: pre,\n        s: sner.numh,\n        p: dig,\n        a: data,\n    } as Dict<any>;\n\n    [, ked] = Saider.saidify(ked);\n\n    return new Serder(ked);\n}\n\nexport function reply(\n    route: string = '',\n    data: any | undefined,\n    stamp: string | undefined,\n    version: Version | undefined,\n    kind: Serials = Serials.JSON\n) {\n    const vs = versify(Ident.KERI, version, kind, 0);\n    if (data == undefined) {\n        data = {};\n    }\n    const _sad = {\n        v: vs,\n        t: Ilks.rpy,\n        d: '',\n        dt: stamp ?? new Date().toISOString().replace('Z', '000+00:00'),\n        r: route,\n        a: data,\n    };\n    const [, sad] = Saider.saidify(_sad);\n    const saider = new Saider({ qb64: sad['d'] });\n\n    if (!saider.verify(sad, true, true, kind, 'd'))\n        throw new Error(`Invalid said = ${saider.qb64} for reply msg=${sad}.`);\n    return new Serder(sad);\n}\n", "import { Algos, Manager } from '../core/manager';\nimport { MtrDex } from '../core/matter';\nimport { Salter } from '../core/salter';\nimport { Verfer } from '../core/verfer';\nimport { Diger } from '../core/diger';\nimport { incept } from '../core/eventing';\nimport { Serder } from '../core/serder';\n\nexport class TraitCodex {\n    EstOnly: string = 'EO'; // Only allow establishment events\n    DoNotDelegate: string = 'DND'; // Dot not allow delegated identifiers\n    NoBackers: string = 'NB'; // Do not allow backers\n}\n\nexport const TraitDex = new TraitCodex();\n\nexport interface HaberyArgs {\n    name: string;\n    passcode?: string;\n    seed?: string | undefined;\n    aeid?: string | undefined;\n    pidx?: number | undefined;\n    salt?: string | undefined;\n    tier?: string | undefined;\n}\n\nexport interface MakeHabArgs {\n    code?: string;\n    transferable?: boolean;\n    isith?: string;\n    icount?: number;\n    nsith?: string;\n    ncount?: number;\n    toad?: string | number;\n    wits?: Array<string>;\n    delpre?: string;\n    estOnly?: boolean;\n    DnD?: boolean;\n    data?: any;\n}\n\nexport class Hab {\n    public name: string;\n    public serder: Serder;\n\n    constructor(name: string, icp: Serder) {\n        this.name = name;\n        this.serder = icp;\n    }\n\n    get pre(): string {\n        return this.serder.ked['i'];\n    }\n}\n\nexport class Habery {\n    private readonly _name: string;\n    private readonly _mgr: Manager;\n    private readonly _habs: Map<string, Hab> = new Map<string, Hab>();\n\n    constructor({ name, passcode, seed, aeid, pidx, salt }: HaberyArgs) {\n        this._name = name;\n        if (passcode != undefined && seed == undefined) {\n            if (passcode.length < 21) {\n                throw new Error('Bran (passcode seed material) too short.');\n            }\n\n            const bran = MtrDex.Salt_128 + 'A' + passcode.substring(0, 21); // qb64 salt for seed\n            const signer = new Salter({ qb64: bran }).signer(\n                MtrDex.Ed25519_Seed,\n                false\n            );\n            seed = signer.qb64;\n            if (aeid == undefined) {\n                aeid = signer.verfer.qb64; // lest it remove encryption\n            }\n        }\n        let algo;\n        const salter =\n            salt != undefined ? new Salter({ qb64: salt }) : undefined;\n        if (salt != undefined) {\n            algo = Algos.salty;\n        } else {\n            algo = Algos.randy;\n        }\n\n        this._mgr = new Manager({\n            seed: seed,\n            aeid: aeid,\n            pidx: pidx,\n            algo: algo,\n            salter: salter,\n        });\n    }\n\n    get mgr(): Manager {\n        return this._mgr;\n    }\n\n    get habs(): Array<Hab> {\n        return Array.from(this._habs.values());\n    }\n\n    habByName(name: string): Hab | undefined {\n        return this._habs.get(name);\n    }\n\n    makeHab(\n        name: string,\n        {\n            code = MtrDex.Blake3_256,\n            transferable = true,\n            isith = undefined,\n            icount = 1,\n            nsith = undefined,\n            ncount = undefined,\n            toad = undefined,\n            wits = undefined,\n            delpre = undefined,\n            estOnly = false,\n            DnD = false,\n            data = undefined,\n        }: MakeHabArgs\n    ): Hab {\n        if (nsith == undefined) {\n            nsith = isith;\n        }\n        if (ncount == undefined) {\n            ncount = icount;\n        }\n        if (!transferable) {\n            ncount = 0;\n            nsith = '0';\n            code = MtrDex.Ed25519N;\n        }\n\n        const [verfers, digers] = this._mgr.incept({\n            icount: icount,\n            ncount: ncount,\n            stem: this.name,\n            transferable: transferable,\n            temp: false,\n        });\n\n        icount = verfers.length;\n        ncount = digers != undefined ? digers.length : 0;\n        if (isith == undefined) {\n            isith = `${Math.max(1, Math.ceil(icount / 2)).toString(16)}`;\n        }\n        if (nsith == undefined) {\n            nsith = `${Math.max(1, Math.ceil(ncount / 2)).toString(16)}`;\n        }\n\n        const cnfg = new Array<string>();\n        if (estOnly) {\n            cnfg.push(TraitDex.EstOnly);\n        }\n        if (DnD) {\n            cnfg.push(TraitDex.DoNotDelegate);\n        }\n\n        const keys = Array.from(verfers, (verfer: Verfer) => verfer.qb64);\n        const ndigs = Array.from(digers, (diger: Diger) => diger.qb64);\n\n        const icp = incept({\n            keys,\n            isith,\n            ndigs,\n            nsith,\n            toad,\n            wits,\n            cnfg,\n            data,\n            code,\n            delpre,\n        });\n        const hab = new Hab(name, icp);\n        this._habs.set(name, hab);\n        return hab;\n    }\n\n    get name(): string {\n        return this._name;\n    }\n}\n", "import { SaltyCreator } from '../core/manager';\nimport { Salter, Tier } from '../core/salter';\nimport { MtrDex } from '../core/matter';\nimport { Diger } from '../core/diger';\nimport { incept, rotate, interact } from '../core/eventing';\nimport { Serder } from '../core/serder';\nimport { Tholder } from '../core/tholder';\nimport { Ilks, b, Serials, Versionage } from '../core/core';\nimport { Verfer } from '../core/verfer';\nimport { Encrypter } from '../core/encrypter';\nimport { Decrypter } from '../core/decrypter';\nimport { Cipher } from '../core/cipher';\nimport { Seqner } from '../core/seqner';\nimport { CesrNumber } from '../core/number';\n\n/**\n * Agent is a custodial entity that can be used in conjuntion with a local Client to establish the\n * KERI \"signing at the edge\" semantic\n */\nexport class Agent {\n    pre: string;\n    anchor: string;\n    verfer: Verfer | null;\n    state: any | null;\n    sn: number | undefined;\n    said: string | undefined;\n\n    constructor(agent: any) {\n        this.pre = '';\n        this.anchor = '';\n        this.verfer = null;\n        this.state = null;\n        this.sn = 0;\n        this.said = '';\n        this.parse(agent);\n    }\n\n    private parse(agent: Agent) {\n        const [state, verfer] = this.event(agent);\n\n        this.sn = new CesrNumber({}, undefined, state['s']).num;\n        this.said = state['d'];\n\n        if (state['et'] !== Ilks.dip) {\n            throw new Error(`invalid inception event type ${state['et']}`);\n        }\n\n        this.pre = state['i'];\n        if (!state['di']) {\n            throw new Error('no anchor to controller AID');\n        }\n\n        this.anchor = state['di'];\n\n        this.verfer = verfer;\n        this.state = state;\n    }\n\n    private event(evt: any): [any, Verfer, Diger] {\n        if (evt['k'].length !== 1) {\n            throw new Error(`agent inception event can only have one key`);\n        }\n\n        const verfer = new Verfer({ qb64: evt['k'][0] });\n\n        if (evt['n'].length !== 1) {\n            throw new Error(`agent inception event can only have one next key`);\n        }\n\n        const diger = new Diger({ qb64: evt['n'][0] });\n\n        const tholder = new Tholder({ sith: evt['kt'] });\n        if (tholder.num !== 1) {\n            throw new Error(`invalid threshold ${tholder.num}, must be 1`);\n        }\n\n        const ntholder = new Tholder({ sith: evt['nt'] });\n        if (ntholder.num !== 1) {\n            throw new Error(\n                `invalid next threshold ${ntholder.num}, must be 1`\n            );\n        }\n        return [evt, verfer, diger];\n    }\n}\n\n/**\n * Controller is responsible for managing signing keys for the client and agent.  The client\n * signing key represents the Account for the client on the agent\n */\nexport class Controller {\n    private bran: string;\n    public stem: string;\n    public tier: Tier;\n    public ridx: number;\n    public salter: any;\n    public signer: any;\n    private nsigner: any;\n    public serder: Serder;\n    private keys: string[];\n    public ndigs: string[];\n\n    constructor(\n        bran: string,\n        tier: Tier,\n        ridx: number = 0,\n        state: any | null = null\n    ) {\n        this.bran = MtrDex.Salt_128 + 'A' + bran.substring(0, 21); // qb64 salt for seed\n        this.stem = 'signify:controller';\n        this.tier = tier;\n        this.ridx = ridx;\n\n        this.salter = new Salter({ qb64: this.bran, tier: this.tier });\n\n        const creator = new SaltyCreator(\n            this.salter.qb64,\n            this.tier,\n            this.stem\n        );\n\n        this.signer = creator\n            .create(\n                undefined,\n                1,\n                MtrDex.Ed25519_Seed,\n                true,\n                0,\n                this.ridx,\n                0,\n                false\n            )\n            .signers.pop();\n        this.nsigner = creator\n            .create(\n                undefined,\n                1,\n                MtrDex.Ed25519_Seed,\n                true,\n                0,\n                this.ridx + 1,\n                0,\n                false\n            )\n            .signers.pop();\n        this.keys = [this.signer.verfer.qb64];\n        this.ndigs = [\n            new Diger({ code: MtrDex.Blake3_256 }, this.nsigner.verfer.qb64b)\n                .qb64,\n        ];\n\n        if (state == null || state['ee']['s'] == 0) {\n            this.serder = incept({\n                keys: this.keys,\n                isith: '1',\n                nsith: '1',\n                ndigs: this.ndigs,\n                code: MtrDex.Blake3_256,\n                toad: '0',\n                wits: [],\n            });\n        } else {\n            this.serder = new Serder(state['ee']);\n        }\n    }\n\n    approveDelegation(_agent: Agent) {\n        const seqner = new Seqner({ sn: _agent.sn });\n        const anchor = { i: _agent.pre, s: seqner.snh, d: _agent.said };\n        const sn = new CesrNumber({}, undefined, this.serder.ked['s']).num + 1;\n        this.serder = interact({\n            pre: this.serder.pre,\n            dig: this.serder.ked['d'],\n            sn: sn,\n            data: [anchor],\n            version: Versionage,\n            kind: Serials.JSON,\n        });\n        return [this.signer.sign(this.serder.raw, 0).qb64];\n    }\n\n    get pre(): string {\n        return this.serder.pre;\n    }\n\n    get event() {\n        const siger = this.signer.sign(this.serder.raw, 0);\n        return [this.serder, siger];\n    }\n\n    get verfers(): [] {\n        return this.signer.verfer();\n    }\n\n    derive(state: any) {\n        if (state != undefined && state['ee']['s'] === '0') {\n            return incept({\n                keys: this.keys,\n                isith: '1',\n                nsith: '1',\n                ndigs: this.ndigs,\n                code: MtrDex.Blake3_256,\n                toad: '0',\n                wits: [],\n            });\n        } else {\n            return new Serder({ ked: state.controller['ee'] });\n        }\n    }\n\n    rotate(bran: string, aids: Array<any>) {\n        const nbran = MtrDex.Salt_128 + 'A' + bran.substring(0, 21); // qb64 salt for seed\n        const nsalter = new Salter({ qb64: nbran, tier: this.tier });\n        const nsigner = this.salter.signer(undefined, false);\n\n        const creator = new SaltyCreator(\n            this.salter.qb64,\n            this.tier,\n            this.stem\n        );\n        const signer = creator\n            .create(\n                undefined,\n                1,\n                MtrDex.Ed25519_Seed,\n                true,\n                0,\n                this.ridx + 1,\n                0,\n                false\n            )\n            .signers.pop();\n\n        const ncreator = new SaltyCreator(nsalter.qb64, this.tier, this.stem);\n        this.signer = ncreator\n            .create(\n                undefined,\n                1,\n                MtrDex.Ed25519_Seed,\n                true,\n                0,\n                this.ridx,\n                0,\n                false\n            )\n            .signers.pop();\n        this.nsigner = ncreator\n            .create(\n                undefined,\n                1,\n                MtrDex.Ed25519_Seed,\n                true,\n                0,\n                this.ridx + 1,\n                0,\n                false\n            )\n            .signers.pop();\n\n        this.keys = [this.signer.verfer.qb64, signer?.verfer.qb64];\n        this.ndigs = [new Diger({}, this.nsigner.verfer.qb64b).qb64];\n\n        const rot = rotate({\n            pre: this.pre,\n            keys: this.keys,\n            dig: this.serder.ked['d'],\n            isith: ['1', '0'],\n            nsith: '1',\n            ndigs: this.ndigs,\n        });\n\n        const sigs = [\n            signer?.sign(b(rot.raw), 1, false, 0).qb64,\n            this.signer.sign(rot.raw, 0).qb64,\n        ];\n        const encrypter = new Encrypter({}, b(nsigner.verfer.qb64));\n        const decrypter = new Decrypter({}, nsigner.qb64b);\n        const sxlt = encrypter.encrypt(b(this.bran)).qb64;\n\n        const keys: Record<any, any> = {};\n\n        for (const aid of aids) {\n            const pre: string = aid['prefix'] as string;\n            if ('salty' in aid) {\n                const salty: any = aid['salty'];\n                const cipher = new Cipher({ qb64: salty['sxlt'] });\n                const dnxt = decrypter.decrypt(null, cipher).qb64;\n\n                // Now we have the AID salt, use it to verify against the current public keys\n                const acreator = new SaltyCreator(\n                    dnxt,\n                    salty['tier'],\n                    salty['stem']\n                );\n                const signers = acreator.create(\n                    salty['icodes'],\n                    undefined,\n                    MtrDex.Ed25519_Seed,\n                    salty['transferable'],\n                    salty['pidx'],\n                    0,\n                    salty['kidx'],\n                    false\n                );\n                const _signers = [];\n                for (const signer of signers.signers) {\n                    _signers.push(signer.verfer.qb64);\n                }\n                const pubs = aid['state']['k'];\n\n                if (pubs.join(',') != _signers.join(',')) {\n                    throw new Error('Invalid Salty AID');\n                }\n\n                const asxlt = encrypter.encrypt(b(dnxt)).qb64;\n                keys[pre] = {\n                    sxlt: asxlt,\n                };\n            } else if ('randy' in aid) {\n                const randy = aid['randy'];\n                const prxs = randy['prxs'];\n                const nxts = randy['nxts'];\n\n                const nprxs = [];\n                const signers = [];\n                for (const prx of prxs) {\n                    const cipher = new Cipher({ qb64: prx });\n                    const dsigner = decrypter.decrypt(null, cipher, true);\n                    signers.push(dsigner);\n                    nprxs.push(encrypter.encrypt(b(dsigner.qb64)).qb64);\n                }\n                const pubs = aid['state']['k'];\n                const _signers = [];\n                for (const signer of signers) {\n                    _signers.push(signer.verfer.qb64);\n                }\n\n                if (pubs.join(',') != _signers.join(',')) {\n                    throw new Error(\n                        `unable to rotate, validation of encrypted public keys ${pubs} failed`\n                    );\n                }\n\n                const nnxts = [];\n                for (const nxt of nxts) {\n                    nnxts.push(this.recrypt(nxt, decrypter, encrypter));\n                }\n\n                keys[pre] = {\n                    prxs: nprxs,\n                    nxts: nnxts,\n                };\n            } else {\n                throw new Error('invalid aid type ');\n            }\n        }\n\n        const data = {\n            rot: rot.ked,\n            sigs: sigs,\n            sxlt: sxlt,\n            keys: keys,\n        };\n        return data;\n    }\n\n    recrypt(enc: string, decrypter: Decrypter, encrypter: Encrypter) {\n        const cipher = new Cipher({ qb64: enc });\n        const dnxt = decrypter.decrypt(null, cipher).qb64;\n        return encrypter.encrypt(b(dnxt)).qb64;\n    }\n}\n", "import {\n    serializeDictionary,\n    Dictionary,\n    parseDictionary,\n    Item,\n    Parameters,\n} from 'structured-headers';\nimport { Signer } from './signer';\nimport { b } from './core';\nimport { Cigar } from './cigar';\nimport { nowUTC } from './utils';\nimport { Siger } from './siger';\nimport { Buffer } from 'buffer';\nimport { encodeBase64Url } from './base64';\n\nexport const HEADER_SIG_INPUT = normalize('Signature-Input');\nexport const HEADER_SIG_TIME = normalize('Signify-Timestamp');\n\nexport function normalize(header: string) {\n    return header.trim();\n}\n\nexport interface SiginputArgs {\n    name: string;\n    method: string;\n    path: string;\n    headers: Headers;\n    fields: Array<string>;\n    expires?: number;\n    nonce?: string;\n    alg?: string;\n    keyid?: string;\n    context?: string;\n}\n\nexport function siginput(\n    signer: Signer,\n    {\n        name,\n        method,\n        path,\n        headers,\n        fields,\n        expires,\n        nonce,\n        alg,\n        keyid,\n        context,\n    }: SiginputArgs\n): [Map<string, string>, Siger | Cigar] {\n    const items = new Array<string>();\n    const ifields = new Array<[string, Map<string, string>]>();\n\n    fields.forEach((field) => {\n        if (field.startsWith('@')) {\n            switch (field) {\n                case '@method':\n                    items.push(`\"${field}\": ${method}`);\n                    ifields.push([field, new Map()]);\n                    break;\n                case '@path':\n                    items.push(`\"${field}\": ${path}`);\n                    ifields.push([field, new Map()]);\n                    break;\n            }\n        } else {\n            if (!headers.has(field)) return;\n\n            ifields.push([field, new Map()]);\n            const value = normalize(headers.get(field)!);\n            items.push(`\"${field}\": ${value}`);\n        }\n    });\n\n    const nameParams = new Map<string, string | number>();\n    const now = Math.floor(nowUTC().getTime() / 1000);\n    nameParams.set('created', now);\n\n    const values = [\n        `(${ifields.map((field) => field[0]).join(' ')})`,\n        `created=${now}`,\n    ];\n    if (expires != undefined) {\n        values.push(`expires=${expires}`);\n        nameParams.set('expires', expires);\n    }\n    if (nonce != undefined) {\n        values.push(`nonce=${nonce}`);\n        nameParams.set('nonce', nonce);\n    }\n    if (keyid != undefined) {\n        values.push(`keyid=${keyid}`);\n        nameParams.set('keyid', keyid);\n    }\n    if (context != undefined) {\n        values.push(`context=${context}`);\n        nameParams.set('context', context);\n    }\n    if (alg != undefined) {\n        values.push(`alg=${alg}`);\n        nameParams.set('alg', alg);\n    }\n    const sid = new Map([[name, [ifields, nameParams]]]);\n\n    const params = values.join(';');\n    items.push(`\"@signature-params: ${params}\"`);\n\n    const ser = items.join('\\n');\n    const sig = signer.sign(b(ser));\n\n    return [\n        new Map<string, string>([\n            [HEADER_SIG_INPUT, `${serializeDictionary(sid as Dictionary)}`],\n        ]),\n        sig,\n    ];\n}\n\nexport class Unqualified {\n    private readonly _raw: Uint8Array;\n\n    constructor(raw: Uint8Array) {\n        this._raw = raw;\n    }\n\n    get qb64(): string {\n        return encodeBase64Url(Buffer.from(this._raw));\n    }\n\n    get qb64b(): Uint8Array {\n        return b(this.qb64);\n    }\n}\n\nexport class Inputage {\n    public name: any;\n    public fields: any;\n    public created: any;\n    public expires: any;\n    public nonce: any;\n    public alg: any;\n    public keyid: any;\n    public context: any;\n}\n\nexport function desiginput(value: string): Array<Inputage> {\n    const sid = parseDictionary(value);\n    const siginputs = new Array<Inputage>();\n\n    sid.forEach((value, key) => {\n        const siginput = new Inputage();\n        siginput.name = key;\n        let list: Item[];\n        let params;\n        [list, params] = value as [Item[], Parameters];\n        siginput.fields = list.map((item) => item[0]);\n\n        if (!params.has('created')) {\n            throw new Error(\n                'missing required `created` field from signature input'\n            );\n        }\n        siginput.created = params.get('created');\n\n        if (params.has('expires')) {\n            siginput.expires = params.get('expires');\n        }\n\n        if (params.has('nonce')) {\n            siginput.nonce = params.get('nonce');\n        }\n\n        if (params.has('alg')) {\n            siginput.alg = params.get('alg');\n        }\n\n        if (params.has('keyid')) {\n            siginput.keyid = params.get('keyid');\n        }\n\n        if (params.has('context')) {\n            siginput.context = params.get('context');\n        }\n\n        siginputs.push(siginput);\n    });\n\n    return siginputs;\n}\n/** Parse start, end and total from HTTP Content-Range header value\n * @param {string|null} header - HTTP Range header value\n * @param {string} typ - type of range, e.g. \"aids\"\n * @returns {start: number, end: number, total: number} - object with start, end and total properties\n */\nexport function parseRangeHeaders(\n    header: string | null,\n    typ: string\n): { start: number; end: number; total: number } {\n    if (header !== null) {\n        const data = header.replace(`${typ} `, '');\n        const values = data.split('/');\n        const rng = values[0].split('-');\n\n        return {\n            start: parseInt(rng[0]),\n            end: parseInt(rng[1]),\n            total: parseInt(values[1]),\n        };\n    } else {\n        return { start: 0, end: 0, total: 0 };\n    }\n}\n", "import { Tier } from '../core/salter';\nimport { Algos } from '../core/manager';\nimport { incept, interact, reply, rotate } from '../core/eventing';\nimport { b, Ilks, Serials, Versionage } from '../core/core';\nimport { Tholder } from '../core/tholder';\nimport { MtrDex } from '../core/matter';\nimport { Serder } from '../core/serder';\nimport { parseRangeHeaders } from '../core/httping';\nimport { KeyManager } from '../core/keeping';\nimport { Operation } from './coring';\nimport { HabState } from '../core/state';\n\n/** Arguments required to create an identfier */\nexport interface CreateIdentiferArgs {\n    transferable?: boolean;\n    isith?: string | number | string[];\n    nsith?: string | number | string[];\n    wits?: string[];\n    toad?: number;\n    proxy?: string;\n    delpre?: string;\n    dcode?: string;\n    data?: any;\n    algo?: Algos;\n    pre?: string;\n    states?: any[];\n    rstates?: any[];\n    prxs?: any[];\n    nxts?: any[];\n    mhab?: HabState;\n    keys?: string[];\n    ndigs?: string[];\n    bran?: string;\n    count?: number;\n    ncount?: number;\n    tier?: Tier;\n    extern_type?: string;\n    extern?: any;\n}\n\n/** Arguments required to rotate an identfier */\nexport interface RotateIdentifierArgs {\n    transferable?: boolean;\n    nsith?: string | number | string[];\n    toad?: number;\n    cuts?: string[];\n    adds?: string[];\n    data?: Array<object>;\n    ncode?: string;\n    ncount?: number;\n    ncodes?: string[];\n    states?: any[];\n    rstates?: any[];\n}\n\n/**\n * Reducing the SignifyClient dependencies used by Identifier class\n */\nexport interface IdentifierDeps {\n    fetch(\n        pathname: string,\n        method: string,\n        body: unknown,\n        headers?: Headers\n    ): Promise<Response>;\n    pidx: number;\n    manager: KeyManager | null;\n}\n\n/** Identifier */\nexport class Identifier {\n    public client: IdentifierDeps;\n\n    /**\n     * Identifier\n     * @param {IdentifierDeps} client\n     */\n    constructor(client: IdentifierDeps) {\n        this.client = client;\n    }\n\n    /**\n     * List managed identifiers\n     * @async\n     * @param {number} [start=0] Start index of list of notifications, defaults to 0\n     * @param {number} [end=24] End index of list of notifications, defaults to 24\n     * @returns {Promise<any>} A promise to the list of managed identifiers\n     */\n    async list(start: number = 0, end: number = 24): Promise<any> {\n        const extraHeaders = new Headers();\n        extraHeaders.append('Range', `aids=${start}-${end}`);\n\n        const path = `/identifiers`;\n        const data = null;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, data, extraHeaders);\n\n        const cr = res.headers.get('content-range');\n        const range = parseRangeHeaders(cr, 'aids');\n        const aids = await res.json();\n\n        return {\n            start: range.start,\n            end: range.end,\n            total: range.total,\n            aids: aids,\n        };\n    }\n\n    /**\n     * Get information for a managed identifier\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @returns {Promise<any>} A promise to the identifier information\n     */\n    async get(name: string): Promise<HabState> {\n        const path = `/identifiers/${encodeURIComponent(name)}`;\n        const data = null;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n\n    /**\n     * Create a managed identifier\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {CreateIdentiferArgs} [kargs] Optional parameters to create the identifier\n     * @returns {EventResult} The inception result\n     */\n    async create(\n        name: string,\n        kargs: CreateIdentiferArgs = {}\n    ): Promise<EventResult> {\n        const algo = kargs.algo == undefined ? Algos.salty : kargs.algo;\n\n        const transferable = kargs.transferable ?? true;\n        const isith = kargs.isith ?? '1';\n        let nsith = kargs.nsith ?? '1';\n        let wits = kargs.wits ?? [];\n        const toad = kargs.toad ?? 0;\n        let dcode = kargs.dcode ?? MtrDex.Blake3_256;\n        const proxy = kargs.proxy;\n        const delpre = kargs.delpre;\n        const data = kargs.data != undefined ? [kargs.data] : [];\n        const pre = kargs.pre;\n        const states = kargs.states;\n        const rstates = kargs.rstates;\n        const prxs = kargs.prxs;\n        const nxts = kargs.nxts;\n        const mhab = kargs.mhab;\n        const _keys = kargs.keys;\n        const _ndigs = kargs.ndigs;\n        const bran = kargs.bran;\n        const count = kargs.count;\n        let ncount = kargs.ncount;\n        const tier = kargs.tier;\n        const extern_type = kargs.extern_type;\n        const extern = kargs.extern;\n\n        if (!transferable) {\n            ncount = 0;\n            nsith = 0;\n            dcode = MtrDex.Ed25519N;\n        }\n\n        const xargs = {\n            transferable: transferable,\n            isith: isith,\n            nsith: nsith,\n            wits: wits,\n            toad: toad,\n            proxy: proxy,\n            delpre: delpre,\n            dcode: dcode,\n            data: data,\n            algo: algo,\n            pre: pre,\n            prxs: prxs,\n            nxts: nxts,\n            mhab: mhab,\n            states: states,\n            rstates: rstates,\n            keys: _keys,\n            ndigs: _ndigs,\n            bran: bran,\n            count: count,\n            ncount: ncount,\n            tier: tier,\n            extern_type: extern_type,\n            extern: extern,\n        };\n\n        const keeper = this.client.manager!.new(algo, this.client.pidx, xargs);\n        const [keys, ndigs] = await keeper!.incept(transferable);\n        wits = wits !== undefined ? wits : [];\n        let serder: Serder | undefined = undefined;\n        if (delpre == undefined) {\n            serder = incept({\n                keys: keys!,\n                isith: isith,\n                ndigs: ndigs,\n                nsith: nsith,\n                toad: toad,\n                wits: wits,\n                cnfg: [],\n                data: data,\n                version: Versionage,\n                kind: Serials.JSON,\n                code: dcode,\n                intive: false,\n            });\n        } else {\n            serder = incept({\n                keys: keys!,\n                isith: isith,\n                ndigs: ndigs,\n                nsith: nsith,\n                toad: toad,\n                wits: wits,\n                cnfg: [],\n                data: data,\n                version: Versionage,\n                kind: Serials.JSON,\n                code: dcode,\n                intive: false,\n                delpre: delpre,\n            });\n        }\n\n        const sigs = await keeper!.sign(b(serder.raw));\n        const jsondata: any = {\n            name: name,\n            icp: serder.ked,\n            sigs: sigs,\n            proxy: proxy,\n            smids:\n                states != undefined\n                    ? states.map((state) => state.i)\n                    : undefined,\n            rmids:\n                rstates != undefined\n                    ? rstates.map((state) => state.i)\n                    : undefined,\n        };\n        jsondata[algo] = keeper.params();\n\n        this.client.pidx = this.client.pidx + 1;\n        const res = this.client.fetch('/identifiers', 'POST', jsondata);\n        return new EventResult(serder, sigs, res);\n    }\n\n    /**\n     * Generate an interaction event in a managed identifier\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {any} [data] Option data to be anchored in the interaction event\n     * @returns {Promise<EventResult>} A promise to the interaction event result\n     */\n    async interact(name: string, data?: any): Promise<EventResult> {\n        let { serder, sigs, jsondata } = await this.createInteract(name, data);\n\n        const res = await this.client.fetch(\n            '/identifiers/' + name + '/events',\n            'POST',\n            jsondata\n        );\n        return new EventResult(serder, sigs, res);\n    }\n\n    async createInteract(\n        name: string,\n        data?: any\n    ): Promise<{ serder: any; sigs: any; jsondata: any }> {\n        const hab = await this.get(name);\n        const pre: string = hab.prefix;\n\n        const state = hab.state;\n        const sn = parseInt(state.s, 16);\n        const dig = state.d;\n\n        data = Array.isArray(data) ? data : [data];\n\n        const serder = interact({\n            pre: pre,\n            sn: sn + 1,\n            data: data,\n            dig: dig,\n            version: undefined,\n            kind: undefined,\n        });\n        const keeper = this.client!.manager!.get(hab);\n        const sigs = await keeper.sign(b(serder.raw));\n\n        const jsondata: any = {\n            ixn: serder.ked,\n            sigs: sigs,\n        };\n        jsondata[keeper.algo] = keeper.params();\n        return { serder, sigs, jsondata };\n    }\n\n    /**\n     * Generate a rotation event in a managed identifier\n     * @param {string} name Name or alias of the identifier\n     * @param {RotateIdentifierArgs} [kargs] Optional parameters requiered to generate the rotation event\n     * @returns {Promise<EventResult>} A promise to the rotation event result\n     */\n    async rotate(\n        name: string,\n        kargs: RotateIdentifierArgs = {}\n    ): Promise<EventResult> {\n        const transferable = kargs.transferable ?? true;\n        const ncode = kargs.ncode ?? MtrDex.Ed25519_Seed;\n        const ncount = kargs.ncount ?? 1;\n\n        const hab = await this.get(name);\n        const pre = hab.prefix;\n        const delegated = hab.state.di !== '';\n\n        const state = hab.state;\n        const count = state.k.length;\n        const dig = state.d;\n        const ridx = parseInt(state.s, 16) + 1;\n        const wits = state.b;\n        let isith = state.nt;\n\n        let nsith = kargs.nsith ?? isith;\n\n        // if isith is None:  # compute default from newly rotated verfers above\n        if (isith == undefined)\n            isith = `${Math.max(1, Math.ceil(count / 2)).toString(16)}`;\n\n        // if nsith is None:  # compute default from newly rotated digers above\n        if (nsith == undefined)\n            nsith = `${Math.max(1, Math.ceil(ncount / 2)).toString(16)}`;\n\n        const cst = new Tholder({ sith: isith }).sith; // current signing threshold\n        const nst = new Tholder({ sith: nsith }).sith; // next signing threshold\n\n        // Regenerate next keys to sign rotation event\n        const keeper = this.client.manager!.get(hab);\n        // Create new keys for next digests\n        const ncodes = kargs.ncodes ?? new Array(ncount).fill(ncode);\n\n        const states = kargs.states == undefined ? [] : kargs.states;\n        const rstates = kargs.rstates == undefined ? [] : kargs.rstates;\n        const [keys, ndigs] = await keeper!.rotate(\n            ncodes,\n            transferable,\n            states,\n            rstates\n        );\n\n        const cuts = kargs.cuts ?? [];\n        const adds = kargs.adds ?? [];\n        const data = kargs.data != undefined ? [kargs.data] : [];\n        const toad = kargs.toad;\n        const ilk = delegated ? Ilks.drt : Ilks.rot;\n\n        const serder = rotate({\n            pre: pre,\n            ilk: ilk,\n            keys: keys,\n            dig: dig,\n            sn: ridx,\n            isith: cst,\n            nsith: nst,\n            ndigs: ndigs,\n            toad: toad,\n            wits: wits,\n            cuts: cuts,\n            adds: adds,\n            data: data,\n        });\n\n        const sigs = await keeper.sign(b(serder.raw));\n\n        const jsondata: any = {\n            rot: serder.ked,\n            sigs: sigs,\n            smids:\n                states != undefined\n                    ? states.map((state) => state.i)\n                    : undefined,\n            rmids:\n                rstates != undefined\n                    ? rstates.map((state) => state.i)\n                    : undefined,\n        };\n        jsondata[keeper.algo] = keeper.params();\n\n        const res = await this.client.fetch(\n            '/identifiers/' + name + '/events',\n            'POST',\n            jsondata\n        );\n        return new EventResult(serder, sigs, res);\n    }\n\n    /**\n     * Authorize an endpoint provider in a given role for a managed identifier\n     * @remarks\n     * Typically used to authorize the agent to be the endpoint provider for the identifier in the role of `agent`\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {string} role Authorized role for eid\n     * @param {string} [eid] Optional qb64 of endpoint provider to be authorized\n     * @param {string} [stamp=now] Optional date-time-stamp RFC-3339 profile of iso8601 datetime. Now is the default if not provided\n     * @returns {Promise<EventResult>} A promise to the result of the authorization\n     */\n    async addEndRole(\n        name: string,\n        role: string,\n        eid?: string,\n        stamp?: string\n    ): Promise<EventResult> {\n        const hab = await this.get(name);\n        const pre = hab.prefix;\n\n        const rpy = this.makeEndRole(pre, role, eid, stamp);\n        const keeper = this.client.manager!.get(hab);\n        const sigs = await keeper.sign(b(rpy.raw));\n\n        const jsondata = {\n            rpy: rpy.ked,\n            sigs: sigs,\n        };\n\n        const res = this.client.fetch(\n            '/identifiers/' + name + '/endroles',\n            'POST',\n            jsondata\n        );\n        return new EventResult(rpy, sigs, res);\n    }\n\n    /**\n     * Generate an /end/role/add reply message\n     * @param {string} pre Prefix of the identifier\n     * @param {string} role Authorized role for eid\n     * @param {string} [eid] Optional qb64 of endpoint provider to be authorized\n     * @param {string} [stamp=now] Optional date-time-stamp RFC-3339 profile of iso8601 datetime. Now is the default if not provided\n     * @returns {Serder} The reply message\n     */\n    private makeEndRole(\n        pre: string,\n        role: string,\n        eid?: string,\n        stamp?: string\n    ): Serder {\n        const data: any = {\n            cid: pre,\n            role: role,\n        };\n        if (eid != undefined) {\n            data.eid = eid;\n        }\n        const route = '/end/role/add';\n        return reply(route, data, stamp, undefined, Serials.JSON);\n    }\n\n    /**\n     * Get the members of a group identifier\n     * @async\n     * @param {string} name - Name or alias of the identifier\n     * @returns {Promise<any>} - A promise to the list of members\n     */\n    async members(name: string): Promise<any> {\n        const res = await this.client.fetch(\n            '/identifiers/' + name + '/members',\n            'GET',\n            undefined\n        );\n        return await res.json();\n    }\n}\n\n/** Event Result */\nexport class EventResult {\n    private readonly _serder: Serder;\n    private readonly _sigs: string[];\n    private readonly promise: Promise<Response> | Response;\n\n    constructor(\n        serder: Serder,\n        sigs: string[],\n        promise: Promise<Response> | Response\n    ) {\n        this._serder = serder;\n        this._sigs = sigs;\n        this.promise = promise;\n    }\n\n    get serder() {\n        return this._serder;\n    }\n\n    get sigs() {\n        return this._sigs;\n    }\n\n    async op(): Promise<any> {\n        const res = await this.promise;\n        return await res.json();\n    }\n}\n", "import { Siger } from '../core/siger';\nimport { Cigar } from '../core/cigar';\n\nexport const FALSY = [false, 0, '?0', 'no', 'false', 'False', 'off'];\nexport const TRUTHY = [true, 1, '?1', 'yes', 'true', 'True', 'on'];\n\nexport class Signage {\n    constructor(\n        markers: any,\n        indexed?: boolean,\n        signer?: string,\n        ordinal?: string,\n        digest?: string,\n        kind?: string\n    ) {\n        this.markers = markers;\n        this.indexed = indexed;\n        this.signer = signer;\n        this.ordinal = ordinal;\n        this.digest = digest;\n        this.kind = kind;\n    }\n    public markers: any;\n    public indexed: boolean | undefined = false;\n    public signer: string | undefined;\n    public ordinal: string | undefined;\n    public digest: string | undefined;\n    public kind: string | undefined;\n}\n\nexport function signature(signages: Array<Signage>): Headers {\n    const values = new Array<string>();\n\n    for (const signage of signages) {\n        let markers: Array<Siger | Cigar>;\n        let indexed = signage.indexed;\n        const signer = signage.signer;\n        const ordinal = signage.ordinal;\n        const digest = signage.digest;\n        const kind = signage.kind;\n        let tags: Array<string>;\n\n        if (signage.markers instanceof Map) {\n            tags = Array.from(signage.markers.keys());\n            markers = Array.from(signage.markers.values());\n        } else {\n            markers = signage.markers as Array<Siger | Cigar>;\n            tags = new Array<string>();\n        }\n\n        if (indexed == undefined) {\n            indexed = markers[0] instanceof Siger;\n        }\n\n        const items = new Array<string>();\n        const tag = 'indexed';\n\n        let val = indexed ? '?1' : '?0';\n        items.push(`${tag}=\"${val}\"`);\n\n        if (signer != undefined) {\n            items.push(`signer=\"${signer}\"`);\n        }\n        if (ordinal != undefined) {\n            items.push(`ordinal=\"${ordinal}\"`);\n        }\n        if (digest != undefined) {\n            items.push(`digest=\"${digest}\"`);\n        }\n        if (kind != undefined) {\n            items.push(`kind=\"${kind}\"`);\n        }\n\n        markers.forEach((marker, idx) => {\n            let tag: string;\n            if (tags != undefined && tags.length > idx) {\n                tag = tags[idx];\n            } else if (marker instanceof Siger) {\n                if (!indexed)\n                    throw new Error(\n                        `Indexed signature marker ${marker} when indexed False.`\n                    );\n\n                tag = marker.index.toString();\n            } else {\n                // Must be a Cigar\n                if (indexed)\n                    throw new Error(\n                        `Unindexed signature marker ${marker} when indexed True.`\n                    );\n                tag = marker.verfer!.qb64;\n            }\n\n            val = marker.qb64;\n            items.push(`${tag}=\"${val}\"`);\n        });\n\n        values.push(items.join(';'));\n    }\n\n    return new Headers([['Signature', values.join(',')]]);\n}\n\nexport function designature(value: string) {\n    const values = value.replace(' ', '').split(',');\n\n    const signages = new Array<Signage>();\n    values.forEach((val) => {\n        const dict = new Map<string, string>();\n        val.split(';').forEach((v) => {\n            const splits = v.split('=', 2);\n            dict.set(splits[0], splits[1].replaceAll('\"', ''));\n        });\n\n        if (!dict.has('indexed')) {\n            throw new Error(\n                'Missing indexed field in Signature header signage.'\n            );\n        }\n        const item = dict.get('indexed')!;\n        const indexed = !FALSY.includes(item);\n        dict.delete('indexed');\n\n        let signer;\n        if (dict.has('signer')) {\n            signer = dict.get('signer') as string;\n            dict.delete('signer');\n        }\n\n        let ordinal;\n        if (dict.has('ordinal')) {\n            ordinal = dict.get('ordinal') as string;\n            dict.delete('ordinal');\n        }\n\n        let digest;\n        if (dict.has('digest')) {\n            digest = dict.get('digest') as string;\n            dict.delete('digest');\n        }\n\n        let kind;\n        if (dict.has('kind')) {\n            kind = dict.get('kind') as string;\n            dict.delete('kind');\n        } else {\n            kind = 'CESR';\n        }\n\n        let markers: Map<string, string | Siger | Cigar>;\n        if (kind == 'CESR') {\n            markers = new Map<string, Siger | Cigar>();\n            dict.forEach((val, key) => {\n                if (indexed) {\n                    markers.set(key, new Siger({ qb64: val as string }));\n                } else {\n                    markers.set(key, new Cigar({ qb64: val as string }));\n                }\n            });\n        } else {\n            markers = dict;\n        }\n\n        signages.push(\n            new Signage(markers, indexed, signer, ordinal, digest, kind)\n        );\n    });\n\n    return signages;\n}\n", "import { Signer } from './signer';\nimport { Verfer } from './verfer';\nimport {\n    desiginput,\n    HEADER_SIG_INPUT,\n    HEADER_SIG_TIME,\n    normalize,\n    siginput,\n} from './httping';\nimport { Signage, signature, designature } from '../end/ending';\nimport { Cigar } from './cigar';\nimport { Siger } from './siger';\nexport class Authenticater {\n    static DefaultFields = [\n        '@method',\n        '@path',\n        'signify-resource',\n        HEADER_SIG_TIME.toLowerCase(),\n    ];\n    private _verfer: Verfer;\n    private readonly _csig: Signer;\n\n    constructor(csig: Signer, verfer: Verfer) {\n        this._csig = csig;\n        this._verfer = verfer;\n    }\n\n    verify(headers: Headers, method: string, path: string): boolean {\n        const siginput = headers.get(HEADER_SIG_INPUT);\n        if (siginput == null) {\n            return false;\n        }\n        const signature = headers.get('Signature');\n        if (signature == null) {\n            return false;\n        }\n        let inputs = desiginput(siginput);\n        inputs = inputs.filter((input) => input.name == 'signify');\n        if (inputs.length == 0) {\n            return false;\n        }\n        inputs.forEach((input) => {\n            const items = new Array<string>();\n            input.fields!.forEach((field: string) => {\n                if (field.startsWith('@')) {\n                    if (field == '@method') {\n                        items.push(`\"${field}\": ${method}`);\n                    } else if (field == '@path') {\n                        items.push(`\"${field}\": ${path}`);\n                    }\n                } else {\n                    if (headers.has(field)) {\n                        const value = normalize(headers.get(field) as string);\n                        items.push(`\"${field}\": ${value}`);\n                    }\n                }\n            });\n            const values = new Array<string>();\n            values.push(`(${input.fields!.join(' ')})`);\n            values.push(`created=${input.created}`);\n            if (input.expires != undefined) {\n                values.push(`expires=${input.expires}`);\n            }\n            if (input.nonce != undefined) {\n                values.push(`nonce=${input.nonce}`);\n            }\n            if (input.keyid != undefined) {\n                values.push(`keyid=${input.keyid}`);\n            }\n            if (input.context != undefined) {\n                values.push(`context=${input.context}`);\n            }\n            if (input.alg != undefined) {\n                values.push(`alg=${input.alg}`);\n            }\n            const params = values.join(';');\n            items.push(`\"@signature-params: ${params}\"`);\n            const ser = items.join('\\n');\n            const signage = designature(signature!);\n            const cig = signage[0].markers.get(input.name);\n            if (!this._verfer.verify(cig.raw, ser)) {\n                throw new Error(`Signature for ${input.keyid} invalid.`);\n            }\n        });\n\n        return true;\n    }\n\n    sign(\n        headers: Headers,\n        method: string,\n        path: string,\n        fields?: Array<string>\n    ): Headers {\n        if (fields == undefined) {\n            fields = Authenticater.DefaultFields;\n        }\n\n        const [header, sig] = siginput(this._csig, {\n            name: 'signify',\n            method,\n            path,\n            headers,\n            fields,\n            alg: 'ed25519',\n            keyid: this._csig.verfer.qb64,\n        });\n\n        header.forEach((value, key) => {\n            headers.append(key, value);\n        });\n\n        const markers = new Map<string, Siger | Cigar>();\n        markers.set('signify', sig);\n        const signage = new Signage(markers, false);\n        const signed = signature([signage]);\n        signed.forEach((value, key) => {\n            headers.append(key, value);\n        });\n\n        return headers;\n    }\n}\n", "import { Salter } from './salter';\nimport { Algos, SaltyCreator, RandyCreator } from './manager';\nimport { MtrDex } from './matter';\nimport { Tier } from './salter';\nimport { Encrypter } from '../core/encrypter';\nimport { Decrypter } from './decrypter';\nimport { b } from './core';\nimport { Cipher } from './cipher';\nimport { Diger } from './diger';\nimport { Prefixer } from './prefixer';\nimport { Signer } from './signer';\nimport { HabState, State } from './state';\n\n/** External module definition */\nexport interface ExternalModuleType {\n    new (pidx: number, args: KeeperParams): Keeper;\n}\n\nexport interface ExternalModule {\n    type: string;\n    name: string;\n    module: ExternalModuleType;\n}\n\nexport type KeeperResult = [string[], string[]];\nexport type SignResult = string[];\n\nexport interface KeeperParams {\n    [key: string]: unknown;\n}\n\nexport interface SaltyParams extends KeeperParams {\n    pidx: number;\n    kidx: number;\n    tier: Tier;\n    transferable: boolean;\n    stem: string | undefined;\n    icodes: string[] | undefined;\n    ncodes: string[] | undefined;\n    dcode: string | undefined;\n    sxlt: string | undefined;\n}\n\nexport interface RandyParams extends KeeperParams {\n    nxts?: string[];\n    prxs?: string[];\n    transferable: boolean;\n}\n\nexport interface GroupParams extends KeeperParams {\n    mhab: HabState;\n}\n\nexport interface Keeper<T extends KeeperParams = KeeperParams> {\n    algo: Algos;\n    signers: Signer[];\n    params(): T;\n    incept(transferable: boolean): Promise<KeeperResult>;\n    rotate(\n        ncodes: string[],\n        transferable: boolean,\n        states?: State[],\n        rstates?: State[]\n    ): Promise<KeeperResult>;\n    sign(\n        ser: Uint8Array,\n        indexed?: boolean,\n        indices?: number[],\n        ondices?: number[]\n    ): Promise<SignResult>;\n}\n\nexport class KeyManager {\n    private modules: Record<string, ExternalModuleType> = {};\n\n    constructor(\n        private salter: Salter,\n        externalModules: ExternalModule[] = []\n    ) {\n        this.salter = salter;\n\n        for (const mod of externalModules) {\n            this.modules[mod.type] = mod.module;\n        }\n    }\n\n    new(algo: Algos, pidx: number, kargs: any) {\n        switch (algo) {\n            case Algos.salty:\n                return new SaltyKeeper(\n                    this.salter!,\n                    pidx,\n                    kargs['kidx'],\n                    kargs['tier'],\n                    kargs['transferable'],\n                    kargs['stem'],\n                    kargs['code'],\n                    kargs['count'],\n                    kargs['icodes'],\n                    kargs['ncode'],\n                    kargs['ncount'],\n                    kargs['ncodes'],\n                    kargs['dcode'],\n                    kargs['bran'],\n                    kargs['sxlt']\n                );\n            case Algos.randy:\n                return new RandyKeeper(\n                    this.salter!,\n                    kargs['code'],\n                    kargs['count'],\n                    kargs['icodes'],\n                    kargs['transferable'],\n                    kargs['ncode'],\n                    kargs['ncount'],\n                    kargs['ncodes'],\n                    kargs['dcode'],\n                    kargs['prxs'],\n                    kargs['nxts']\n                );\n            case Algos.group:\n                return new GroupKeeper(\n                    this,\n                    kargs['mhab'],\n                    kargs['states'],\n                    kargs['rstates'],\n                    kargs['keys'],\n                    kargs['ndigs']\n                );\n            case Algos.extern: {\n                const ModuleConstructor = this.modules[kargs.extern_type];\n                if (!ModuleConstructor) {\n                    throw new Error(\n                        `unsupported external module type ${kargs.extern_type}`\n                    );\n                }\n\n                return new ModuleConstructor(pidx, kargs);\n            }\n            default:\n                throw new Error('Unknown algo');\n        }\n    }\n\n    get(aid: HabState): Keeper {\n        if (aid[Algos.salty]) {\n            const kargs = aid[Algos.salty];\n            return new SaltyKeeper(\n                this.salter,\n                kargs['pidx'],\n                kargs['kidx'],\n                kargs['tier'],\n                kargs['transferable'],\n                kargs['stem'],\n                undefined,\n                undefined,\n                kargs['icodes'],\n                undefined,\n                undefined,\n                kargs['ncodes'],\n                kargs['dcode'],\n                undefined,\n                kargs['sxlt']\n            );\n        } else if (aid[Algos.randy]) {\n            const pre = new Prefixer({ qb64: aid['prefix'] });\n            const kargs = aid[Algos.randy]!;\n            return new RandyKeeper(\n                this.salter,\n                undefined,\n                undefined,\n                undefined,\n                pre.transferable,\n                undefined,\n                undefined,\n                [],\n                undefined,\n                kargs['prxs'],\n                kargs['nxts']\n            );\n        } else if (aid[Algos.group]) {\n            const kargs = aid[Algos.group];\n            return new GroupKeeper(\n                this,\n                kargs['mhab'],\n                undefined,\n                undefined,\n                kargs['keys'],\n                kargs['ndigs']\n            );\n        } else if (aid[Algos.extern]) {\n            const kargs = aid[Algos.extern];\n            const typ = kargs.extern_type;\n            if (typ in this.modules) {\n                const mod = new this.modules[typ](kargs['pidx'], kargs);\n                return mod;\n            } else {\n                throw new Error(`unsupported external module type ${typ}`);\n            }\n        } else {\n            throw new Error(`Algo not allowed yet`);\n        }\n    }\n}\n\nexport class SaltyKeeper implements Keeper {\n    private aeid: string;\n    private encrypter: Encrypter;\n    private decrypter: Decrypter;\n    private salter: Salter;\n    private pidx: number;\n    private kidx: number;\n    private tier: Tier;\n    private transferable: boolean;\n    private stem: string | undefined;\n    private code: string;\n    private count: number;\n    private icodes: string[] | undefined;\n    private ncode: string;\n    private ncount: number;\n    private ncodes: string[] | undefined;\n    private dcode: string | undefined;\n    private sxlt: string | undefined;\n    private bran: string | undefined;\n    private creator: SaltyCreator;\n    public algo: Algos = Algos.salty;\n    public signers: Signer[];\n\n    constructor(\n        salter: Salter,\n        pidx: number,\n        kidx: number = 0,\n        tier = Tier.low,\n        transferable = false,\n        stem: string | undefined = undefined,\n        code = MtrDex.Ed25519_Seed,\n        count = 1,\n        icodes: string[] | undefined = undefined,\n        ncode = MtrDex.Ed25519_Seed,\n        ncount = 1,\n        ncodes: string[] | undefined = undefined,\n        dcode = MtrDex.Blake3_256,\n        bran: string | undefined = undefined,\n        sxlt: string | undefined = undefined\n    ) {\n        // # Salter is the entered passcode and used for enc/dec of salts for each AID\n        this.salter = salter;\n        const signer = this.salter.signer(undefined, (transferable = false));\n\n        this.aeid = signer.verfer.qb64;\n\n        this.encrypter = new Encrypter({}, b(this.aeid));\n        this.decrypter = new Decrypter({}, signer.qb64b);\n\n        this.code = code;\n        this.ncode = ncode;\n        this.tier = tier;\n        this.icodes =\n            icodes == undefined ? new Array<string>(count).fill(code) : icodes;\n        this.ncodes =\n            ncodes == undefined\n                ? new Array<string>(ncount).fill(ncode)\n                : ncodes;\n        this.dcode = dcode;\n        this.pidx = pidx;\n        this.kidx = kidx;\n        this.transferable = transferable;\n        this.count = count;\n        this.ncount = ncount;\n        this.stem = stem == undefined ? 'signify:aid' : stem;\n\n        if (bran != undefined) {\n            this.bran = MtrDex.Salt_128 + 'A' + bran!.slice(0, 21);\n            this.creator = new SaltyCreator(this.bran, this.tier, this.stem);\n            this.sxlt = this.encrypter.encrypt(b(this.creator.salt)).qb64;\n        } else if (sxlt == undefined) {\n            this.creator = new SaltyCreator(undefined, this.tier, this.stem);\n            this.sxlt = this.encrypter.encrypt(b(this.creator.salt)).qb64;\n        } else {\n            this.sxlt = sxlt;\n            const ciph = new Cipher({ qb64: this.sxlt });\n            this.creator = new SaltyCreator(\n                this.decrypter.decrypt(null, ciph).qb64,\n                tier,\n                this.stem\n            );\n        }\n\n        this.signers = this.creator.create(\n            this.icodes,\n            this.ncount,\n            this.ncode,\n            this.transferable,\n            this.pidx,\n            0,\n            this.kidx,\n            false\n        ).signers;\n    }\n\n    params(): SaltyParams {\n        return {\n            sxlt: this.sxlt,\n            pidx: this.pidx,\n            kidx: this.kidx,\n            stem: this.stem,\n            tier: this.tier,\n            icodes: this.icodes,\n            ncodes: this.ncodes,\n            dcode: this.dcode,\n            transferable: this.transferable,\n        };\n    }\n\n    async incept(transferable: boolean): Promise<KeeperResult> {\n        this.transferable = transferable;\n        this.kidx = 0;\n\n        const signers = this.creator.create(\n            this.icodes,\n            this.count,\n            this.code,\n            this.transferable,\n            this.pidx,\n            0,\n            this.kidx,\n            false\n        );\n        const verfers = signers.signers.map((signer) => signer.verfer.qb64);\n\n        const nsigners = this.creator.create(\n            this.ncodes,\n            this.ncount,\n            this.ncode,\n            this.transferable,\n            this.pidx,\n            0,\n            this.icodes?.length,\n            false\n        );\n        const digers = nsigners.signers.map(\n            (nsigner) =>\n                new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n        );\n\n        return [verfers, digers];\n    }\n\n    async rotate(\n        ncodes: string[],\n        transferable: boolean\n    ): Promise<[string[], string[]]> {\n        this.ncodes = ncodes;\n        this.transferable = transferable;\n        const signers = this.creator.create(\n            this.ncodes,\n            this.ncount,\n            this.ncode,\n            this.transferable,\n            this.pidx,\n            0,\n            this.kidx + this.icodes!.length,\n            false\n        );\n        const verfers = signers.signers.map((signer) => signer.verfer.qb64);\n\n        this.kidx = this.kidx! + this.icodes!.length;\n        const nsigners = this.creator.create(\n            this.ncodes,\n            this.ncount,\n            this.ncode,\n            this.transferable,\n            this.pidx,\n            0,\n            this.kidx + this.icodes!.length,\n            false\n        );\n        const digers = nsigners.signers.map(\n            (nsigner) =>\n                new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n        );\n\n        return [verfers, digers];\n    }\n\n    async sign(\n        ser: Uint8Array,\n        indexed = true,\n        indices: number[] | undefined = undefined,\n        ondices: number[] | undefined = undefined\n    ): Promise<SignResult> {\n        const signers = this.creator.create(\n            this.icodes,\n            this.ncount,\n            this.ncode,\n            this.transferable,\n            this.pidx,\n            0,\n            this.kidx,\n            false\n        );\n\n        if (indexed) {\n            const sigers = [];\n            let i = 0;\n            for (const [j, signer] of signers.signers.entries()) {\n                if (indices != undefined) {\n                    i = indices![j];\n                    if (typeof i != 'number' || i < 0) {\n                        throw new Error(\n                            `Invalid signing index = ${i}, not whole number.`\n                        );\n                    }\n                } else {\n                    i = j;\n                }\n                let o = 0;\n                if (ondices != undefined) {\n                    o = ondices![j];\n                    if (\n                        (o == undefined ||\n                            (typeof o == 'number' &&\n                                typeof o != 'number' &&\n                                o >= 0))!\n                    ) {\n                        throw new Error(\n                            `Invalid ondex = ${o}, not whole number.`\n                        );\n                    }\n                } else {\n                    o = i;\n                }\n                sigers.push(\n                    signer.sign(ser, i, o == undefined ? true : false, o)\n                );\n            }\n            return sigers.map((siger) => siger.qb64);\n        } else {\n            const cigars = [];\n            for (const [, signer] of signers.signers.entries()) {\n                cigars.push(signer.sign(ser));\n            }\n            return cigars.map((cigar) => cigar.qb64);\n        }\n    }\n}\n\nexport class RandyKeeper implements Keeper {\n    private salter: Salter;\n    private code: string;\n    private count: number;\n    private icodes: string[] | undefined;\n    private transferable: boolean;\n    private ncount: number;\n    private ncodes: string[] | undefined;\n    private ncode: string;\n    private dcode: string | undefined;\n    private prxs: string[] | undefined;\n    private nxts: string[] | undefined;\n    private aeid: string;\n    private encrypter: Encrypter;\n    private decrypter: Decrypter;\n    private creator: RandyCreator;\n    public algo: Algos = Algos.randy;\n    public signers: Signer[];\n\n    constructor(\n        salter: Salter,\n        code = MtrDex.Ed25519_Seed,\n        count = 1,\n        icodes: string[] | undefined = undefined,\n        transferable = false,\n        ncode = MtrDex.Ed25519_Seed,\n        ncount = 1,\n        ncodes: string[],\n        dcode = MtrDex.Blake3_256,\n        prxs: string[] | undefined = undefined,\n        nxts: string[] | undefined = undefined\n    ) {\n        this.salter = salter;\n        this.icodes =\n            icodes == undefined ? new Array<string>(count).fill(code) : icodes;\n        this.ncodes =\n            ncodes == undefined\n                ? new Array<string>(ncount).fill(ncode)\n                : ncodes;\n\n        this.code = code;\n        this.ncode = ncode;\n        this.count = count;\n        this.ncount = ncount;\n\n        const signer = this.salter.signer(undefined, (transferable = false));\n        this.aeid = signer.verfer.qb64;\n\n        this.encrypter = new Encrypter({}, b(this.aeid));\n        this.decrypter = new Decrypter({}, signer.qb64b);\n\n        this.nxts = nxts ?? [];\n        this.prxs = prxs ?? [];\n        this.transferable = transferable;\n\n        this.icodes = icodes;\n        this.ncodes = ncodes;\n        this.dcode = dcode;\n\n        this.creator = new RandyCreator();\n\n        this.signers = this.prxs.map((prx) =>\n            this.decrypter.decrypt(\n                new Cipher({ qb64: prx }).qb64b,\n                undefined,\n                this.transferable\n            )\n        );\n    }\n\n    params(): RandyParams {\n        return {\n            nxts: this.nxts,\n            prxs: this.prxs,\n            transferable: this.transferable,\n        };\n    }\n\n    async incept(transferable: boolean): Promise<KeeperResult> {\n        this.transferable = transferable;\n\n        const signers = this.creator.create(\n            this.icodes,\n            this.count,\n            this.code,\n            this.transferable\n        );\n        this.prxs = signers.signers.map(\n            (signer) => this.encrypter.encrypt(undefined, signer).qb64\n        );\n\n        const verfers = signers.signers.map((signer) => signer.verfer.qb64);\n\n        const nsigners = this.creator.create(\n            this.ncodes,\n            this.ncount,\n            this.ncode,\n            this.transferable\n        );\n\n        this.nxts = nsigners.signers.map(\n            (signer) => this.encrypter.encrypt(undefined, signer).qb64\n        );\n\n        const digers = nsigners.signers.map(\n            (nsigner) =>\n                new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n        );\n\n        return [verfers, digers];\n    }\n\n    async rotate(\n        ncodes: string[],\n        transferable: boolean\n    ): Promise<KeeperResult> {\n        this.ncodes = ncodes;\n        this.transferable = transferable;\n        this.prxs = this.nxts;\n\n        const signers = this.nxts!.map((nxt) =>\n            this.decrypter.decrypt(\n                undefined,\n                new Cipher({ qb64: nxt }),\n                this.transferable\n            )\n        );\n        const verfers = signers.map((signer) => signer.verfer.qb64);\n        const nsigners = this.creator.create(\n            this.ncodes,\n            this.ncount,\n            this.ncode,\n            this.transferable\n        );\n\n        this.nxts = nsigners.signers.map(\n            (signer) => this.encrypter.encrypt(undefined, signer).qb64\n        );\n\n        const digers = nsigners.signers.map(\n            (nsigner) =>\n                new Diger({ code: this.dcode }, nsigner.verfer.qb64b).qb64\n        );\n\n        return [verfers, digers];\n    }\n\n    async sign(\n        ser: Uint8Array,\n        indexed = true,\n        indices: number[] | undefined = undefined,\n        ondices: number[] | undefined = undefined\n    ): Promise<SignResult> {\n        const signers = this.prxs!.map((prx) =>\n            this.decrypter.decrypt(\n                new Cipher({ qb64: prx }).qb64b,\n                undefined,\n                this.transferable\n            )\n        );\n\n        if (indexed) {\n            const sigers = [];\n            let i = 0;\n            for (const [j, signer] of signers.entries()) {\n                if (indices != undefined) {\n                    i = indices![j];\n                    if (typeof i != 'number' || i < 0) {\n                        throw new Error(\n                            `Invalid signing index = ${i}, not whole number.`\n                        );\n                    }\n                } else {\n                    i = j;\n                }\n                let o = 0;\n                if (ondices != undefined) {\n                    o = ondices![j];\n                    if (\n                        (o == undefined ||\n                            (typeof o == 'number' &&\n                                typeof o != 'number' &&\n                                o >= 0))!\n                    ) {\n                        throw new Error(\n                            `Invalid ondex = ${o}, not whole number.`\n                        );\n                    }\n                } else {\n                    o = i;\n                }\n                sigers.push(\n                    signer.sign(ser, i, o == undefined ? true : false, o)\n                );\n            }\n            return sigers.map((siger) => siger.qb64);\n        } else {\n            const cigars = [];\n            for (const [, signer] of signers.entries()) {\n                cigars.push(signer.sign(ser));\n            }\n            return cigars.map((cigar) => cigar.qb64);\n        }\n    }\n}\n\nexport class GroupKeeper implements Keeper {\n    private manager: KeyManager;\n    private mhab: HabState;\n    private gkeys: string[] = [];\n    private gdigs: string[] = [];\n    public algo: Algos = Algos.group;\n    public signers: Signer[];\n\n    constructor(\n        manager: KeyManager,\n        mhab: HabState,\n        states: State[] | undefined = undefined,\n        rstates: State[] | undefined = undefined,\n        keys: string[] = [],\n        ndigs: string[] = []\n    ) {\n        this.manager = manager;\n        if (states != undefined) {\n            keys = states.map((state) => state['k'][0]);\n        }\n\n        if (rstates != undefined) {\n            ndigs = rstates.map((state) => state['n'][0]);\n        }\n\n        this.gkeys = states?.map((state) => state['k'][0]) ?? keys;\n        this.gdigs = rstates?.map((state) => state['n'][0]) ?? ndigs;\n        this.mhab = mhab;\n        this.signers = [];\n    }\n\n    async incept(): Promise<KeeperResult> {\n        return [this.gkeys, this.gdigs];\n    }\n\n    async rotate(\n        _ncodes: string[],\n        _transferable: boolean,\n        states: State[],\n        rstates: State[]\n    ): Promise<KeeperResult> {\n        this.gkeys = states.map((state) => state['k'][0]);\n        this.gdigs = rstates.map((state) => state['n'][0]);\n        return [this.gkeys, this.gdigs];\n    }\n\n    async sign(ser: Uint8Array, indexed: boolean = true): Promise<SignResult> {\n        if (!this.mhab.state) {\n            throw new Error(`No state in mhab`);\n        }\n\n        const key = this.mhab['state']['k'][0];\n        const ndig = this.mhab['state']['n'][0];\n\n        const csi = this.gkeys!.indexOf(key);\n        const pni = this.gdigs!.indexOf(ndig);\n        const mkeeper = this.manager.get(this.mhab);\n\n        return await mkeeper.sign(ser, indexed, [csi], [pni]);\n    }\n\n    params() {\n        return {\n            mhab: this.mhab,\n            keys: this.gkeys,\n            ndigs: this.gdigs,\n        };\n    }\n}\n", "import { SignifyClient } from './clienting';\nimport { Operation } from './coring';\n\n/**\n * Contacts\n */\nexport class Contacts {\n    client: SignifyClient;\n    /**\n     * Contacts\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * List contacts\n     * @async\n     * @param {string} [group] Optional group name to filter contacts\n     * @param {string} [filterField] Optional field name to filter contacts\n     * @param {string} [filterValue] Optional field value to filter contacts\n     * @returns {Promise<any>} A promise to the list of contacts\n     */\n    async list(\n        group?: string,\n        filterField?: string,\n        filterValue?: string\n    ): Promise<any> {\n        const params = new URLSearchParams();\n        if (group !== undefined) {\n            params.append('group', group);\n        }\n        if (filterField !== undefined && filterValue !== undefined) {\n            params.append('filter_field', filterField);\n            params.append('filter_value', filterValue);\n        }\n\n        const path = `/contacts` + '?' + params.toString();\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n\n    /**\n     * Get a contact\n     * @async\n     * @param {string} pre Prefix of the contact\n     * @returns {Promise<any>} A promise to the contact\n     */\n    async get(pre: string): Promise<any> {\n        const path = `/contacts/` + pre;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n\n    /**\n     * Add a contact\n     * @async\n     * @param {string} pre Prefix of the contact\n     * @param {any} info Information about the contact\n     * @returns {Promise<any>} A promise to the result of the addition\n     */\n    async add(pre: string, info: any): Promise<any> {\n        const path = `/contacts/` + pre;\n        const method = 'POST';\n\n        const res = await this.client.fetch(path, method, info);\n        return await res.json();\n    }\n\n    /**\n     * Delete a contact\n     * @async\n     * @param {string} pre Prefix of the contact\n     * @returns {Promise<void>}\n     */\n    async delete(pre: string): Promise<void> {\n        const path = `/contacts/` + pre;\n        const method = 'DELETE';\n\n        await this.client.fetch(path, method, null);\n    }\n\n    /**\n     * Update a contact\n     * @async\n     * @param {string} pre Prefix of the contact\n     * @param {any} info Updated information about the contact\n     * @returns {Promise<any>} A promise to the result of the update\n     */\n    async update(pre: string, info: any): Promise<any> {\n        const path = `/contacts/` + pre;\n        const method = 'PUT';\n\n        const res = await this.client.fetch(path, method, info);\n        return await res.json();\n    }\n}\n\n/**\n * Challenges\n */\nexport class Challenges {\n    client: SignifyClient;\n    /**\n     * Challenges\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Generate a random challenge word list based on BIP39\n     * @async\n     * @param {number} strength Integer representing the strength of the challenge. Typically 128 or 256\n     * @returns {Promise<any>} A promise to the list of random words\n     */\n    async generate(strength: number = 128): Promise<any> {\n        const path = `/challenges?strength=${strength.toString()}`;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n\n    /**\n     * Respond to a challenge by signing a message with the list of words\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {string} recipient Prefix of the recipient of the response\n     * @param {Array<string>} words List of words to embed in the signed response\n     * @returns {Promise<Response>} A promise to the result of the response\n     */\n    async respond(\n        name: string,\n        recipient: string,\n        words: string[]\n    ): Promise<Response> {\n        const hab = await this.client.identifiers().get(name);\n        const exchanges = this.client.exchanges();\n        const resp = await exchanges.send(\n            name,\n            'challenge',\n            hab,\n            '/challenge/response',\n            { words: words },\n            {},\n            [recipient]\n        );\n        return resp;\n    }\n\n    /**\n     * Ask Agent to verify a given sender signed the provided words\n     * @param {string} source Prefix of the identifier that was challenged\n     * @param {Array<string>} words List of challenge words to check for\n     * @returns A promise to the long running operation\n     */\n    async verify(source: string, words: string[]): Promise<Operation<unknown>> {\n        const path = `/challenges_verify/${source}`;\n        const method = 'POST';\n        const data = {\n            words: words,\n        };\n        const res = await this.client.fetch(path, method, data);\n\n        return await res.json();\n    }\n\n    /**\n     * Mark challenge response as signed and accepted\n     * @param {string} source Prefix of the identifier that was challenged\n     * @param {string} said qb64 AID of exn message representing the signed response\n     * @returns {Promise<Response>} A promise to the result\n     */\n    async responded(source: string, said: string): Promise<Response> {\n        const path = `/challenges_verify/${source}`;\n        const method = 'PUT';\n        const data = {\n            said: said,\n        };\n        const res = await this.client.fetch(path, method, data);\n        return res;\n    }\n}\n", "import { SignifyClient } from './clienting';\nimport libsodium from 'libsodium-wrappers-sumo';\nimport { Salter } from '../core/salter';\nimport { Matter, MtrDex } from '../core/matter';\n\nexport function randomPasscode(): string {\n    const raw = libsodium.randombytes_buf(16);\n    const salter = new Salter({ raw: raw });\n\n    // https://github.com/WebOfTrust/signify-ts/issues/242\n    return salter.qb64.substring(2, 23);\n}\n\nexport function randomNonce(): string {\n    const seed = libsodium.randombytes_buf(libsodium.crypto_sign_SEEDBYTES);\n    const seedqb64 = new Matter({ raw: seed, code: MtrDex.Ed25519_Seed });\n    return seedqb64.qb64;\n}\n\nexport class Oobis {\n    public client: SignifyClient;\n    /**\n     * Oobis\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Get the OOBI(s) for a managed indentifier for a given role\n     * @param {string} name Name or alias of the identifier\n     * @param {string} role Authorized role\n     * @returns {Promise<any>} A promise to the OOBI(s)\n     */\n    async get(name: string, role: string = 'agent'): Promise<any> {\n        const path = `/identifiers/${name}/oobis?role=${role}`;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n\n    /**\n     * Resolve an OOBI\n     * @async\n     * @param {string} oobi The OOBI to be resolver\n     * @param {string} [alias] Optional name or alias to link the OOBI resolution to a contact\n     * @returns {Promise<any>} A promise to the long-running operation\n     */\n    async resolve(oobi: string, alias?: string): Promise<any> {\n        const path = `/oobis`;\n        const data: any = {\n            url: oobi,\n        };\n        if (alias !== undefined) {\n            data.oobialias = alias;\n        }\n        const method = 'POST';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n}\n\nexport interface Operation<T = unknown> {\n    name: string;\n    metadata?: {\n        depends?: Operation;\n        [property: string]: any;\n    };\n    done?: boolean;\n    error?: any;\n    response?: T;\n}\n\nexport interface OperationsDeps {\n    fetch(\n        pathname: string,\n        method: string,\n        body: unknown,\n        headers?: Headers\n    ): Promise<Response>;\n}\n\n/**\n * Operations\n * @remarks\n * Operations represent the status and result of long running tasks performed by KERIA agent\n */\nexport class Operations {\n    public client: OperationsDeps;\n    /**\n     * Operations\n     * @param {SignifyClient} client\n     */\n    constructor(client: OperationsDeps) {\n        this.client = client;\n    }\n\n    /**\n     * Get operation status\n     * @async\n     * @param {string} name Name of the operation\n     * @returns {Promise<Operation>} A promise to the status of the operation\n     */\n    async get<T = unknown>(name: string): Promise<Operation<T>> {\n        const path = `/operations/${name}`;\n        const data = null;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n    /**\n     * List operations\n     * @async\n     * @param {string} type Select operations by type\n     * @returns {Promise<Operation[]>} A list of operations\n     */\n    async list(type?: string): Promise<Operation<any>[]> {\n        const params = new URLSearchParams();\n        if (type !== undefined) {\n            params.append('type', type);\n        }\n        const path = `/operations?${params.toString()}`;\n        const data = null;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n    /**\n     * Delete operation\n     * @async\n     * @param {string} name Name of the operation\n     */\n    async delete(name: string): Promise<void> {\n        const path = `/operations/${name}`;\n        const data = null;\n        const method = 'DELETE';\n        await this.client.fetch(path, method, data);\n    }\n\n    /**\n     * Poll for operation to become completed.\n     */\n    async wait<T>(\n        op: Operation<T>,\n        options: {\n            signal?: AbortSignal;\n            minSleep?: number;\n            maxSleep?: number;\n            increaseFactor?: number;\n        } = {}\n    ): Promise<Operation<T>> {\n        const minSleep = options.minSleep ?? 10;\n        const maxSleep = options.maxSleep ?? 10000;\n        const increaseFactor = options.increaseFactor ?? 50;\n\n        if (op.metadata?.depends?.done === false) {\n            await this.wait(op.metadata.depends, options);\n        }\n\n        if (op.done === true) {\n            return op;\n        }\n\n        let retries = 0;\n\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            op = await this.get(op.name);\n\n            const delay = Math.max(\n                minSleep,\n                Math.min(maxSleep, 2 ** retries * increaseFactor)\n            );\n            retries++;\n\n            if (op.done === true) {\n                return op;\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            options.signal?.throwIfAborted();\n        }\n    }\n}\n\n/**\n * KeyEvents\n */\nexport class KeyEvents {\n    public client: SignifyClient;\n    /**\n     * KeyEvents\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Retrieve key events for an identifier\n     * @async\n     * @param {string} pre Identifier prefix\n     * @returns {Promise<any>} A promise to the key events\n     */\n    async get(pre: string): Promise<any> {\n        const path = `/events?pre=${pre}`;\n        const data = null;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n}\n\n/**\n * KeyStates\n */\nexport class KeyStates {\n    public client: SignifyClient;\n    /**\n     * KeyStates\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Retriene the key state for an identifier\n     * @async\n     * @param {string} pre Identifier prefix\n     * @returns {Promise<any>} A promise to the key states\n     */\n    async get(pre: string): Promise<any> {\n        const path = `/states?pre=${pre}`;\n        const data = null;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n\n    /**\n     * Retrieve the key state for a list of identifiers\n     * @async\n     * @param {Array<string>} pres List of identifier prefixes\n     * @returns {Promise<any>} A promise to the key states\n     */\n    async list(pres: string[]): Promise<any> {\n        const path = `/states?${pres.map((pre) => `pre=${pre}`).join('&')}`;\n        const data = null;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n\n    /**\n     * Query the key state of an identifier for a given sequence number or anchor\n     * @async\n     * @param {string} pre Identifier prefix\n     * @param {number} [sn] Optional sequence number\n     * @param {any} [anchor] Optional anchor\n     * @returns {Promise<any>} A promise to the long-running operation\n     */\n    async query(pre: string, sn?: string, anchor?: any): Promise<any> {\n        const path = `/queries`;\n        const data: any = {\n            pre: pre,\n        };\n        if (sn !== undefined) {\n            data.sn = sn;\n        }\n        if (anchor !== undefined) {\n            data.anchor = anchor;\n        }\n\n        const method = 'POST';\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n}\n", "import { randomNonce } from '../app/coring';\nimport { TraitDex } from '../app/habery';\nimport {\n    Serials,\n    Versionage,\n    Version,\n    Ident,\n    versify,\n    Ilks,\n} from '../core/core';\nimport { ample } from './eventing';\nimport { MtrDex } from './matter';\nimport { Prefixer } from './prefixer';\nimport { Serder } from './serder';\n\nnamespace vdr {\n    export interface VDRInceptArgs {\n        pre: string;\n        toad?: number | string;\n        nonce?: string;\n        baks?: string[];\n        cnfg?: string[];\n        version?: Version;\n        kind?: Serials;\n        code?: string;\n    }\n\n    export function incept({\n        pre,\n        toad,\n        nonce = randomNonce(),\n        baks = [],\n        cnfg = [],\n        version = Versionage,\n        kind = Serials.JSON,\n        code = MtrDex.Blake3_256,\n    }: VDRInceptArgs): Serder {\n        const vs = versify(Ident.KERI, version, kind, 0);\n        const isn = 0;\n        const ilk = Ilks.vcp;\n\n        if (cnfg.includes(TraitDex.NoBackers) && baks.length > 0) {\n            throw new Error(\n                `${baks.length} backers specified for NB vcp, 0 allowed`\n            );\n        }\n\n        if (new Set(baks).size < baks.length) {\n            throw new Error(`Invalid baks ${baks} has duplicates`);\n        }\n\n        let _toad: number;\n        if (toad === undefined) {\n            if (baks.length === 0) {\n                _toad = 0;\n            } else {\n                _toad = ample(baks.length);\n            }\n        } else {\n            _toad = +toad;\n        }\n\n        if (baks.length > 0) {\n            if (_toad < 1 || _toad > baks.length) {\n                throw new Error(`Invalid toad ${_toad} for baks in ${baks}`);\n            }\n        } else {\n            if (_toad != 0) {\n                throw new Error(`Invalid toad ${_toad} for no baks`);\n            }\n        }\n\n        const ked = {\n            v: vs,\n            t: ilk,\n            d: '',\n            i: '',\n            ii: pre,\n            s: '' + isn,\n            c: cnfg,\n            bt: _toad.toString(16),\n            b: baks,\n            n: nonce,\n        };\n\n        const prefixer = new Prefixer({ code }, ked);\n        ked.i = prefixer.qb64;\n        ked.d = prefixer.qb64;\n\n        return new Serder(ked);\n    }\n}\n\nexport { vdr };\n", "import { SignifyClient } from './clienting';\nimport { interact, messagize } from '../core/eventing';\nimport { vdr } from '../core/vdring';\nimport {\n    b,\n    d,\n    Dict,\n    Ident,\n    Ilks,\n    Serials,\n    versify,\n    Versionage,\n} from '../core/core';\nimport { Saider } from '../core/saider';\nimport { Serder } from '../core/serder';\nimport { Siger } from '../core/siger';\nimport { TraitDex } from './habery';\nimport {\n    serializeACDCAttachment,\n    serializeIssExnAttachment,\n} from '../core/utils';\nimport { Operation } from './coring';\nimport { HabState } from '../core/state';\n\n/** Types of credentials */\nexport class CredentialTypes {\n    static issued = 'issued';\n    static received = 'received';\n}\n\n/** Credential filter parameters */\nexport interface CredentialFilter {\n    filter?: object;\n    sort?: object[];\n    skip?: number;\n    limit?: number;\n}\n\nexport interface CredentialSubject {\n    /**\n     * Issuee, or holder of the credential.\n     */\n    i?: string;\n    /**\n     * Timestamp of issuance.\n     */\n    dt?: string;\n    /**\n     * Privacy salt\n     */\n    u?: string;\n    [key: string]: unknown;\n}\n\nexport interface CredentialData {\n    v?: string;\n    d?: string;\n    /**\n     * Privacy salt\n     */\n    u?: string;\n    /**\n     * Issuer of the credential.\n     */\n    i?: string;\n    /**\n     * Registry id.\n     */\n    ri?: string;\n    /**\n     * Schema id\n     */\n    s?: string;\n    /**\n     * Credential subject data\n     */\n    a: CredentialSubject;\n    /**\n     * Credential source section\n     */\n    e?: { [key: string]: unknown };\n    /**\n     * Credential rules section\n     */\n    r?: { [key: string]: unknown };\n}\n\nexport interface IssueCredentialResult {\n    acdc: Serder;\n    anc: Serder;\n    iss: Serder;\n    op: Operation;\n}\n\nexport interface RevokeCredentialResult {\n    anc: Serder;\n    rev: Serder;\n    op: Operation;\n}\n\nexport interface IpexApplyArgs {\n    /**\n     * Alias for the IPEX sender AID\n     */\n    senderName: string;\n\n    /**\n     * Prefix of the IPEX recipient AID\n     */\n    recipient: string;\n\n    /**\n     * Message to send\n     */\n    message?: string;\n\n    /**\n     * SAID of schema to apply for\n     */\n    schemaSaid: string;\n\n    /**\n     * Optional attributes for selective disclosure\n     */\n    attributes?: Record<string, unknown>;\n    datetime?: string;\n}\n\nexport interface IpexOfferArgs {\n    /**\n     * Alias for the IPEX sender AID\n     */\n    senderName: string;\n\n    /**\n     * Prefix of the IPEX recipient AID\n     */\n    recipient: string;\n\n    /**\n     * Message to send\n     */\n    message?: string;\n\n    /**\n     * ACDC to offer\n     */\n    acdc: Serder;\n\n    /**\n     * Optional qb64 SAID of apply message this offer is responding to\n     */\n    applySaid?: string;\n    datetime?: string;\n}\n\nexport interface IpexAgreeArgs {\n    /**\n     * Alias for the IPEX sender AID\n     */\n    senderName: string;\n\n    /**\n     * Prefix of the IPEX recipient AID\n     */\n    recipient: string;\n\n    /**\n     * Message to send\n     */\n    message?: string;\n\n    /**\n     * qb64 SAID of offer message this agree is responding to\n     */\n    offerSaid: string;\n    datetime?: string;\n}\n\nexport interface IpexGrantArgs {\n    /**\n     * Alias for the IPEX sender AID\n     */\n    senderName: string;\n\n    /**\n     * Prefix of the IPEX recipient AID\n     */\n    recipient: string;\n\n    /**\n     * Message to send\n     */\n    message?: string;\n\n    /**\n     * qb64 SAID of agree message this grant is responding to\n     */\n    agreeSaid?: string;\n    datetime?: string;\n    acdc: Serder;\n    acdcAttachment?: string;\n    iss: Serder;\n    issAttachment?: string;\n    anc: Serder;\n    ancAttachment?: string;\n}\n\nexport interface IpexAdmitArgs {\n    /**\n     * Alias for the IPEX sender AID\n     */\n    senderName: string;\n\n    /**\n     * Prefix of the IPEX recipient AID\n     */\n    recipient: string;\n\n    /**\n     * Message to send\n     */\n    message?: string;\n\n    /**\n     * qb64 SAID of agree message this admit is responding to\n     */\n    grantSaid: string;\n    datetime?: string;\n}\n\n/**\n * Credentials\n */\nexport class Credentials {\n    public client: SignifyClient;\n    /**\n     * Credentials\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * List credentials\n     * @async\n     * @param {CredentialFilter} [kargs] Optional parameters to filter the credentials\n     * @returns {Promise<any>} A promise to the list of credentials\n     */\n    async list(kargs: CredentialFilter = {}): Promise<any> {\n        const path = `/credentials/query`;\n        const filtr = kargs.filter === undefined ? {} : kargs.filter;\n        const sort = kargs.sort === undefined ? [] : kargs.sort;\n        const limit = kargs.limit === undefined ? 25 : kargs.limit;\n        const skip = kargs.skip === undefined ? 0 : kargs.skip;\n\n        const data = {\n            filter: filtr,\n            sort: sort,\n            skip: skip,\n            limit: limit,\n        };\n        const method = 'POST';\n\n        const res = await this.client.fetch(path, method, data, undefined);\n        return await res.json();\n    }\n\n    /**\n     * Get a credential\n     * @async\n     * @param {string} said - SAID of the credential\n     * @param {boolean} [includeCESR=false] - Optional flag export the credential in CESR format\n     * @returns {Promise<any>} A promise to the credential\n     */\n    async get(said: string, includeCESR: boolean = false): Promise<any> {\n        const path = `/credentials/${said}`;\n        const method = 'GET';\n        const headers = includeCESR\n            ? new Headers({ Accept: 'application/json+cesr' })\n            : new Headers({ Accept: 'application/json' });\n        const res = await this.client.fetch(path, method, null, headers);\n\n        return includeCESR ? await res.text() : await res.json();\n    }\n\n    /**\n     * Issue a credential\n     */\n    async issue(\n        name: string,\n        args: CredentialData\n    ): Promise<IssueCredentialResult> {\n        const hab = await this.client.identifiers().get(name);\n        const estOnly = hab.state.c !== undefined && hab.state.c.includes('EO');\n        if (estOnly) {\n            // TODO implement rotation event\n            throw new Error('Establishment only not implemented');\n        }\n        if (!this.client.manager) {\n            throw new Error('No manager on client');\n        }\n\n        const keeper = this.client.manager.get(hab);\n\n        const [, subject] = Saider.saidify({\n            d: '',\n            ...args.a,\n            dt: args.a.dt ?? new Date().toISOString().replace('Z', '000+00:00'),\n        });\n\n        const [, acdc] = Saider.saidify({\n            v: versify(Ident.ACDC, undefined, Serials.JSON, 0),\n            d: '',\n            u: args.u,\n            i: args.i ?? hab.prefix,\n            ri: args.ri,\n            s: args.s,\n            a: subject,\n            e: args.e,\n            r: args.r,\n        });\n\n        const [, iss] = Saider.saidify({\n            v: versify(Ident.KERI, undefined, Serials.JSON, 0),\n            t: Ilks.iss,\n            d: '',\n            i: acdc.d,\n            s: '0',\n            ri: args.ri,\n            dt: subject.dt,\n        });\n\n        const sn = parseInt(hab.state.s, 16);\n        const anc = interact({\n            pre: hab.prefix,\n            sn: sn + 1,\n            data: [\n                {\n                    i: iss.i,\n                    s: iss.s,\n                    d: iss.d,\n                },\n            ],\n            dig: hab.state.d,\n            version: undefined,\n            kind: undefined,\n        });\n\n        const sigs = await keeper.sign(b(anc.raw));\n\n        const path = `/identifiers/${hab.name}/credentials`;\n        const method = 'POST';\n        const body = {\n            acdc: acdc,\n            iss: iss,\n            ixn: anc.ked,\n            sigs,\n            [keeper.algo]: keeper.params(),\n        };\n\n        const headers = new Headers({\n            Accept: 'application/json+cesr',\n        });\n\n        const res = await this.client.fetch(path, method, body, headers);\n        const op = await res.json();\n\n        return {\n            acdc: new Serder(acdc),\n            iss: new Serder(iss),\n            anc,\n            op,\n        };\n    }\n\n    /**\n     * Revoke credential\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {string} said SAID of the credential\n     * @param {string} datetime date time of revocation\n     * @returns {Promise<any>} A promise to the long-running operation\n     */\n    async revoke(\n        name: string,\n        said: string,\n        datetime?: string\n    ): Promise<RevokeCredentialResult> {\n        const hab = await this.client.identifiers().get(name);\n        const pre: string = hab.prefix;\n\n        const vs = versify(Ident.KERI, undefined, Serials.JSON, 0);\n        const dt =\n            datetime ?? new Date().toISOString().replace('Z', '000+00:00');\n\n        const cred = await this.get(said);\n\n        // Create rev\n        const _rev = {\n            v: vs,\n            t: Ilks.rev,\n            d: '',\n            i: said,\n            s: '1',\n            ri: cred.sad.ri,\n            p: cred.status.d,\n            dt: dt,\n        };\n\n        const [, rev] = Saider.saidify(_rev);\n\n        // create ixn\n        let ixn = {};\n        let sigs = [];\n\n        const state = hab.state;\n        if (state.c !== undefined && state.c.includes('EO')) {\n            var estOnly = true;\n        } else {\n            var estOnly = false;\n        }\n\n        const sn = parseInt(state.s, 16);\n        const dig = state.d;\n\n        const data: any = [\n            {\n                i: rev.i,\n                s: rev.s,\n                d: rev.d,\n            },\n        ];\n\n        const keeper = this.client!.manager!.get(hab);\n\n        if (estOnly) {\n            // TODO implement rotation event\n            throw new Error('Establishment only not implemented');\n        } else {\n            const serder = interact({\n                pre: pre,\n                sn: sn + 1,\n                data: data,\n                dig: dig,\n                version: undefined,\n                kind: undefined,\n            });\n            sigs = await keeper.sign(b(serder.raw));\n            ixn = serder.ked;\n        }\n\n        const body = {\n            rev: rev,\n            ixn: ixn,\n            sigs: sigs,\n            [keeper.algo]: keeper.params(),\n        };\n\n        const path = `/identifiers/${name}/credentials/${said}`;\n        const method = 'DELETE';\n        const headers = new Headers({\n            Accept: 'application/json+cesr',\n        });\n        const res = await this.client.fetch(path, method, body, headers);\n        const op = await res.json();\n\n        return {\n            rev: new Serder(rev),\n            anc: new Serder(ixn),\n            op,\n        };\n    }\n\n    /**\n     * Present a credential\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {string} said SAID of the credential\n     * @param {string} recipient Identifier prefix of the receiver of the presentation\n     * @param {boolean} [include=true] Flag to indicate whether to stream credential alongside presentation exchange message\n     * @returns {Promise<string>} A promise to the long-running operation\n     */\n    async present(\n        name: string,\n        said: string,\n        recipient: string,\n        include: boolean = true\n    ): Promise<string> {\n        const hab = await this.client.identifiers().get(name);\n        const pre: string = hab.prefix;\n\n        const cred = await this.get(said);\n        const data = {\n            i: cred.sad.i,\n            s: cred.sad.s,\n            n: said,\n        };\n\n        const vs = versify(Ident.KERI, undefined, Serials.JSON, 0);\n\n        const _sad = {\n            v: vs,\n            t: Ilks.exn,\n            d: '',\n            dt: new Date().toISOString().replace('Z', '000+00:00'),\n            r: '/presentation',\n            q: {},\n            a: data,\n        };\n        const [, sad] = Saider.saidify(_sad);\n        const exn = new Serder(sad);\n\n        const keeper = this.client!.manager!.get(hab);\n\n        const sig = await keeper.sign(b(exn.raw), true);\n\n        const siger = new Siger({ qb64: sig[0] });\n        const seal = ['SealLast', { i: pre }];\n        let ims = messagize(exn, [siger], seal, undefined, undefined, true);\n        ims = ims.slice(JSON.stringify(exn.ked).length);\n\n        const body = {\n            exn: exn.ked,\n            sig: new TextDecoder().decode(ims),\n            recipient: recipient,\n            include: include,\n        };\n\n        const path = `/identifiers/${name}/credentials/${said}/presentations`;\n        const method = 'POST';\n        const headers = new Headers({\n            Accept: 'application/json+cesr',\n        });\n        const res = await this.client.fetch(path, method, body, headers);\n        return await res.text();\n    }\n\n    /**\n     * Request a presentation of a credential\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {string} recipient Identifier prefix of the receiver of the presentation\n     * @param {string} schema SAID of the schema\n     * @param {string} [issuer] Optional prefix of the issuer of the credential\n     * @returns {Promise<string>} A promise to the long-running operation\n     */\n    async request(\n        name: string,\n        recipient: string,\n        schema: string,\n        issuer?: string\n    ): Promise<string> {\n        const hab = await this.client.identifiers().get(name);\n        const pre: string = hab.prefix;\n\n        const data: any = {\n            s: schema,\n        };\n        if (issuer !== undefined) {\n            data['i'] = issuer;\n        }\n\n        const vs = versify(Ident.KERI, undefined, Serials.JSON, 0);\n\n        const _sad = {\n            v: vs,\n            t: Ilks.exn,\n            d: '',\n            dt: new Date().toISOString().replace('Z', '000+00:00'),\n            r: '/presentation/request',\n            q: {},\n            a: data,\n        };\n        const [, sad] = Saider.saidify(_sad);\n        const exn = new Serder(sad);\n\n        const keeper = this.client!.manager!.get(hab);\n\n        const sig = await keeper.sign(b(exn.raw), true);\n\n        const siger = new Siger({ qb64: sig[0] });\n        const seal = ['SealLast', { i: pre }];\n        let ims = messagize(exn, [siger], seal, undefined, undefined, true);\n        ims = ims.slice(JSON.stringify(exn.ked).length);\n\n        const body = {\n            exn: exn.ked,\n            sig: new TextDecoder().decode(ims),\n            recipient: recipient,\n        };\n\n        const path = `/identifiers/${name}/requests`;\n        const method = 'POST';\n        const headers = new Headers({\n            Accept: 'application/json+cesr',\n        });\n        const res = await this.client.fetch(path, method, body, headers);\n        return await res.text();\n    }\n}\n\nexport interface CreateRegistryArgs {\n    name: string;\n    registryName: string;\n    toad?: string | number | undefined;\n    noBackers?: boolean;\n    baks?: string[];\n    nonce?: string;\n}\n\nexport class RegistryResult {\n    private readonly _regser: any;\n    private readonly _serder: Serder;\n    private readonly _sigs: string[];\n    private readonly promise: Promise<Response>;\n\n    constructor(\n        regser: Serder,\n        serder: Serder,\n        sigs: any[],\n        promise: Promise<Response>\n    ) {\n        this._regser = regser;\n        this._serder = serder;\n        this._sigs = sigs;\n        this.promise = promise;\n    }\n\n    get regser() {\n        return this._regser;\n    }\n\n    get serder() {\n        return this._serder;\n    }\n\n    get sigs() {\n        return this._sigs;\n    }\n\n    async op(): Promise<any> {\n        const res = await this.promise;\n        return await res.json();\n    }\n}\n\n/**\n * Registries\n */\nexport class Registries {\n    public client: SignifyClient;\n    /**\n     * Registries\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * List registries\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @returns {Promise<any>} A promise to the list of registries\n     */\n    async list(name: string): Promise<any> {\n        const path = `/identifiers/${name}/registries`;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n\n    /**\n     * Create a registry\n     * @async\n     * @param {CreateRegistryArgs}\n     * @returns {Promise<[any, Serder, any[], object]> } A promise to the long-running operation\n     */\n    async create({\n        name,\n        registryName,\n        noBackers = true,\n        toad = 0,\n        baks = [],\n        nonce,\n    }: CreateRegistryArgs): Promise<RegistryResult> {\n        const hab = await this.client.identifiers().get(name);\n        const pre: string = hab.prefix;\n\n        const cnfg: string[] = [];\n        if (noBackers) {\n            cnfg.push(TraitDex.NoBackers);\n        }\n\n        const state = hab.state;\n        const estOnly = state.c !== undefined && state.c.includes('EO');\n        if (estOnly) {\n            cnfg.push(TraitDex.EstOnly);\n        }\n\n        const regser = vdr.incept({ pre, baks, toad, nonce, cnfg });\n\n        if (estOnly) {\n            throw new Error('establishment only not implemented');\n        } else {\n            const state = hab.state;\n            const sn = parseInt(state.s, 16);\n            const dig = state.d;\n\n            const data: any = [\n                {\n                    i: regser.pre,\n                    s: '0',\n                    d: regser.pre,\n                },\n            ];\n\n            const serder = interact({\n                pre: pre,\n                sn: sn + 1,\n                data: data,\n                dig: dig,\n                version: Versionage,\n                kind: Serials.JSON,\n            });\n            const keeper = this.client.manager!.get(hab);\n            const sigs = await keeper.sign(b(serder.raw));\n            const res = this.createFromEvents(\n                hab,\n                name,\n                registryName,\n                regser.ked,\n                serder.ked,\n                sigs\n            );\n            return new RegistryResult(regser, serder, sigs, res);\n        }\n    }\n\n    createFromEvents(\n        hab: HabState,\n        name: string,\n        registryName: string,\n        vcp: Dict<any>,\n        ixn: Dict<any>,\n        sigs: any[]\n    ) {\n        const path = `/identifiers/${name}/registries`;\n        const method = 'POST';\n\n        const data: any = {\n            name: registryName,\n            vcp: vcp,\n            ixn: ixn,\n            sigs: sigs,\n        };\n        const keeper = this.client!.manager!.get(hab);\n        data[keeper.algo] = keeper.params();\n\n        return this.client.fetch(path, method, data);\n    }\n\n    /**\n     * Rename a registry\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {string} registryName Current registry name\n     * @param {string} newName New registry name\n     * @returns {Promise<any>} A promise to the registry record\n     */\n    async rename(\n        name: string,\n        registryName: string,\n        newName: string\n    ): Promise<any> {\n        const path = `/identifiers/${name}/registries/${registryName}`;\n        const method = 'PUT';\n        const data = {\n            name: newName,\n        };\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n}\n/**\n * Schemas\n */\nexport class Schemas {\n    client: SignifyClient;\n    /**\n     * Schemas\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Get a schema\n     * @async\n     * @param {string} said SAID of the schema\n     * @returns {Promise<any>} A promise to the schema\n     */\n    async get(said: string): Promise<any> {\n        const path = `/schema/${said}`;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n\n    /**\n     * List schemas\n     * @async\n     * @returns {Promise<any>} A promise to the list of schemas\n     */\n    async list(): Promise<any> {\n        const path = `/schema`;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n}\n\n/**\n * Ipex\n */\n\nexport class Ipex {\n    client: SignifyClient;\n    /**\n     * Schemas\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Create an IPEX apply EXN message\n     */\n    async apply(args: IpexApplyArgs): Promise<[Serder, string[], string]> {\n        const hab = await this.client.identifiers().get(args.senderName);\n        const data = {\n            m: args.message ?? '',\n            s: args.schemaSaid,\n            a: args.attributes ?? {},\n        };\n\n        return this.client\n            .exchanges()\n            .createExchangeMessage(\n                hab,\n                '/ipex/apply',\n                data,\n                {},\n                args.recipient,\n                args.datetime,\n                undefined\n            );\n    }\n\n    async submitApply(\n        name: string,\n        exn: Serder,\n        sigs: string[],\n        recp: string[]\n    ): Promise<any> {\n        const body = {\n            exn: exn.ked,\n            sigs,\n            rec: recp,\n        };\n\n        const response = await this.client.fetch(\n            `/identifiers/${name}/ipex/apply`,\n            'POST',\n            body\n        );\n\n        return response.json();\n    }\n\n    /**\n     * Create an IPEX offer EXN message\n     */\n    async offer(args: IpexOfferArgs): Promise<[Serder, string[], string]> {\n        const hab = await this.client.identifiers().get(args.senderName);\n        const data = {\n            m: args.message ?? '',\n        };\n\n        return this.client\n            .exchanges()\n            .createExchangeMessage(\n                hab,\n                '/ipex/offer',\n                data,\n                { acdc: [args.acdc, undefined] },\n                args.recipient,\n                args.datetime,\n                args.applySaid\n            );\n    }\n\n    async submitOffer(\n        name: string,\n        exn: Serder,\n        sigs: string[],\n        atc: string,\n        recp: string[]\n    ): Promise<any> {\n        const body = {\n            exn: exn.ked,\n            sigs,\n            atc,\n            rec: recp,\n        };\n\n        const response = await this.client.fetch(\n            `/identifiers/${name}/ipex/offer`,\n            'POST',\n            body\n        );\n\n        return response.json();\n    }\n\n    /**\n     * Create an IPEX agree EXN message\n     */\n    async agree(args: IpexAgreeArgs): Promise<[Serder, string[], string]> {\n        const hab = await this.client.identifiers().get(args.senderName);\n        const data = {\n            m: args.message ?? '',\n        };\n\n        return this.client\n            .exchanges()\n            .createExchangeMessage(\n                hab,\n                '/ipex/agree',\n                data,\n                {},\n                args.recipient,\n                args.datetime,\n                args.offerSaid\n            );\n    }\n\n    async submitAgree(\n        name: string,\n        exn: Serder,\n        sigs: string[],\n        recp: string[]\n    ): Promise<any> {\n        const body = {\n            exn: exn.ked,\n            sigs,\n            rec: recp,\n        };\n\n        const response = await this.client.fetch(\n            `/identifiers/${name}/ipex/agree`,\n            'POST',\n            body\n        );\n\n        return response.json();\n    }\n\n    /**\n     * Create an IPEX grant EXN message\n     */\n    async grant(args: IpexGrantArgs): Promise<[Serder, string[], string]> {\n        const hab = await this.client.identifiers().get(args.senderName);\n        const data = {\n            m: args.message ?? '',\n        };\n\n        let atc = args.ancAttachment;\n        if (atc === undefined) {\n            const keeper = this.client.manager!.get(hab);\n            const sigs = await keeper.sign(b(args.anc.raw));\n            const sigers = sigs.map((sig: string) => new Siger({ qb64: sig }));\n            const ims = d(messagize(args.anc, sigers));\n            atc = ims.substring(args.anc.size);\n        }\n\n        const acdcAtc =\n            args.acdcAttachment === undefined\n                ? d(serializeACDCAttachment(args.iss))\n                : args.acdcAttachment;\n        const issAtc =\n            args.issAttachment === undefined\n                ? d(serializeIssExnAttachment(args.anc))\n                : args.issAttachment;\n\n        const embeds: Record<string, [Serder, string]> = {\n            acdc: [args.acdc, acdcAtc],\n            iss: [args.iss, issAtc],\n            anc: [args.anc, atc],\n        };\n\n        return this.client\n            .exchanges()\n            .createExchangeMessage(\n                hab,\n                '/ipex/grant',\n                data,\n                embeds,\n                args.recipient,\n                args.datetime,\n                args.agreeSaid\n            );\n    }\n\n    async submitGrant(\n        name: string,\n        exn: Serder,\n        sigs: string[],\n        atc: string,\n        recp: string[]\n    ): Promise<any> {\n        const body = {\n            exn: exn.ked,\n            sigs: sigs,\n            atc: atc,\n            rec: recp,\n        };\n\n        const response = await this.client.fetch(\n            `/identifiers/${name}/ipex/grant`,\n            'POST',\n            body\n        );\n\n        return response.json();\n    }\n\n    /**\n     * Create an IPEX admit EXN message\n     */\n    async admit(args: IpexAdmitArgs): Promise<[Serder, string[], string]> {\n        const hab = await this.client.identifiers().get(args.senderName);\n        const data: any = {\n            m: args.message,\n        };\n\n        return this.client\n            .exchanges()\n            .createExchangeMessage(\n                hab,\n                '/ipex/admit',\n                data,\n                {},\n                args.recipient,\n                args.datetime,\n                args.grantSaid\n            );\n    }\n\n    async submitAdmit(\n        name: string,\n        exn: Serder,\n        sigs: string[],\n        atc: string,\n        recp: string[]\n    ): Promise<any> {\n        const body = {\n            exn: exn.ked,\n            sigs: sigs,\n            atc: atc,\n            rec: recp,\n        };\n\n        const response = await this.client.fetch(\n            `/identifiers/${name}/ipex/admit`,\n            'POST',\n            body\n        );\n\n        return response.json();\n    }\n}\n", "import { EventResult } from './aiding';\nimport { SignifyClient } from './clienting';\n\nexport class Delegations {\n    public client: SignifyClient;\n    /**\n     * Delegations\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Approve the delegation via interaction event\n     * @async\n     * @param {string} name Name or alias of the identifier\n     * @param {any} [data] The anchoring interaction event\n     * @returns {Promise<EventResult>} A promise to the delegated approval result\n     */\n    async approve(name: string, data?: any): Promise<EventResult> {\n        let { serder, sigs, jsondata } = await this.client\n            .identifiers()\n            .createInteract(name, data);\n\n        const res = await this.client.fetch(\n            '/identifiers/' + name + '/delegation',\n            'POST',\n            jsondata\n        );\n        return new EventResult(serder, sigs, res);\n    }\n}\n", "import { SignifyClient } from './clienting';\n\n/**\n * Escrows\n */\nexport class Escrows {\n    client: SignifyClient;\n\n    /**\n     * Escrows\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * List replay messages\n     * @async\n     * @param {string} [route] Optional route in the replay message\n     * @returns {Promise<any>} A promise to the list of replay messages\n     */\n    async listReply(route?: string): Promise<any> {\n        const params = new URLSearchParams();\n        if (route !== undefined) {\n            params.append('route', route);\n        }\n\n        const path = `/escrows/rpy` + '?' + params.toString();\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n}\n", "import { BexDex, Matter, MatterArgs, MtrDex } from './matter';\nimport { EmptyMaterialError } from './kering';\nimport { Buffer } from 'buffer';\nimport { decodeBase64Url, encodeBase64Url } from './base64';\n\nconst B64REX = '^[A-Za-z0-9\\\\-_]*$';\nexport const Reb64 = new RegExp(B64REX);\n\n/*\n\n    Bexter is subclass of Matter, cryptographic material, for variable length\n    strings that only contain Base64 URL safe characters, i.e. Base64 text (bext).\n    When created using the 'bext' paramaeter, the encoded matter in qb64 format\n    in the text domain is more compact than would be the case if the string were\n    passed in as raw bytes. The text is used as is to form the value part of the\n    qb64 version not including the leader.\n\n    Due to ambiguity that arises from pre-padding bext whose length is a multiple of\n    three with one or more 'A' chars. Any bext that starts with an 'A' and whose length\n    is either a multiple of 3 or 4 may not round trip. Bext with a leading 'A'\n    whose length is a multiple of four may have the leading 'A' stripped when\n    round tripping.\n\n        Bexter(bext='ABBB').bext == 'BBB'\n        Bexter(bext='BBB').bext == 'BBB'\n        Bexter(bext='ABBB').qb64 == '4AABABBB' == Bexter(bext='BBB').qb64\n\n    To avoid this problem, only use for applications of base 64 strings that\n    never start with 'A'\n\n    Examples: base64 text strings:\n\n    bext = \"\"\n    qb64 = '4AAA'\n\n    bext = \"-\"\n    qb64 = '6AABAAA-'\n\n    bext = \"-A\"\n    qb64 = '5AABAA-A'\n\n    bext = \"-A-\"\n    qb64 = '4AABA-A-'\n\n    bext = \"-A-B\"\n    qb64 = '4AAB-A-B'\n\n\n    Example uses:\n        CESR encoded paths for nested SADs and SAIDs\n        CESR encoded fractionally weighted threshold expressions\n\n\n    Attributes:\n\n    Inherited Properties:  (See Matter)\n        .pad  is int number of pad chars given raw\n\n        .code is  str derivation code to indicate cypher suite\n        .raw is bytes crypto material only without code\n        .index is int count of attached crypto material by context (receipts)\n        .qb64 is str in Base64 fully qualified with derivation code + crypto mat\n        .qb64b is bytes in Base64 fully qualified with derivation code + crypto mat\n        .qb2  is bytes in binary with derivation code + crypto material\n        .transferable is Boolean, True when transferable derivation code False otherwise\n\n    Properties:\n        .text is the Base64 text value, .qb64 with text code and leader removed.\n\n    Hidden:\n        ._pad is method to compute  .pad property\n        ._code is str value for .code property\n        ._raw is bytes value for .raw property\n        ._index is int value for .index property\n        ._infil is method to compute fully qualified Base64 from .raw and .code\n        ._exfil is method to extract .code and .raw from fully qualified Base64\n\n    Methods:\n\n\n\n\n */\n\nexport class Bexter extends Matter {\n    constructor(\n        { raw, code = MtrDex.StrB64_L0, qb64b, qb64, qb2 }: MatterArgs,\n        bext?: string\n    ) {\n        if (\n            raw === undefined &&\n            qb64b === undefined &&\n            qb64 === undefined &&\n            qb2 === undefined\n        ) {\n            if (bext === undefined)\n                throw new EmptyMaterialError('Missing bext string.');\n\n            const match = Reb64.exec(bext);\n            if (!match) throw new Error('Invalid Base64.');\n\n            raw = Bexter._rawify(bext);\n        }\n\n        super({ raw, code, qb64b, qb64, qb2 });\n\n        if (!BexDex.has(this.code))\n            throw new Error(`Invalid code = ${this.code} for Bexter.`);\n    }\n\n    static _rawify(bext: string): Uint8Array {\n        const ts = bext.length % 4; // bext size mod 4\n        const ws = (4 - ts) % 4; // pre conv wad size in chars\n        const ls = (3 - ts) % 3; // post conv lead size in bytes\n        const wad = new Array(ws);\n        wad.fill('A');\n        const base = wad.join('') + bext; // pre pad with wad of zeros in Base64 == 'A'\n        const raw = decodeBase64Url(base); // [ls:]  // convert and remove leader\n\n        return Uint8Array.from(raw).subarray(ls); // raw binary equivalent of text\n    }\n\n    get bext(): string {\n        const sizage = Matter.Sizes.get(this.code);\n        const wad = Uint8Array.from(new Array(sizage?.ls).fill(0));\n        const bext = encodeBase64Url(Buffer.from([...wad, ...this.raw]));\n\n        let ws = 0;\n        if (sizage?.ls === 0 && bext !== undefined) {\n            if (bext[0] === 'A') {\n                ws = 1;\n            }\n        } else {\n            ws = (sizage?.ls! + 1) % 4;\n        }\n\n        return bext.substring(ws);\n    }\n}\n", "import { Bexter, Reb64 } from './bexter';\nimport { MatterArgs, MtrDex } from './matter';\nimport { EmptyMaterialError } from './kering';\n\n/*\n    Pather is a subclass of Bexter that provides SAD Path language specific functionality\n    for variable length strings that only contain Base64 URL safe characters.  Pather allows\n    the specification of SAD Paths as a list of field components which will be converted to the\n    Base64 URL safe character representation.\n\n    Additionally, Pather provides .rawify for extracting and serializing the content targeted by\n    .path for a SAD, represented as an instance of Serder.  Pather enforces Base64 URL character\n    safety by leveraging the fact that SADs must have static field ordering.  Any field label can\n    be replaced by its field ordinal to allow for path specification and traversal for any field\n    labels that contain non-Base64 URL safe characters.\n\n\n    Examples: strings:\n        path = []\n        text = \"-\"\n        qb64 = '6AABAAA-'\n\n        path = [\"A\"]\n        text = \"-A\"\n        qb64 = '5AABAA-A'\n\n        path = [\"A\", \"B\"]\n        text = \"-A-B\"\n        qb64 = '4AAB-A-B'\n\n        path = [\"A\", 1, \"B\", 3]\n        text = \"-A-1-B-3\"\n        qb64 = '4AAC-A-1-B-3'\n\n */\n\nexport class Pather extends Bexter {\n    constructor(\n        { raw, code = MtrDex.StrB64_L0, qb64b, qb64, qb2 }: MatterArgs,\n        bext?: string,\n        path?: string[]\n    ) {\n        if (\n            raw === undefined &&\n            bext === undefined &&\n            qb64b === undefined &&\n            qb64 === undefined &&\n            qb2 === undefined\n        ) {\n            if (path === undefined)\n                throw new EmptyMaterialError('Missing bext string.');\n\n            bext = Pather._bextify(path);\n        }\n\n        super({ raw, code, qb64b, qb64, qb2 }, bext);\n    }\n\n    // TODO: implement SAD access methods like resolve, root, strip, startswith and tail\n\n    get path(): string[] {\n        if (!this.bext.startsWith('-')) {\n            throw new Error('invalid SAD ptr');\n        }\n\n        let path = this.bext;\n        while (path.charAt(0) === '-') {\n            path = path.substring(1);\n        }\n\n        const apath = path.split('-');\n        if (apath[0] !== '') {\n            return apath;\n        } else {\n            return [];\n        }\n    }\n\n    static _bextify(path: any[]): string {\n        const vath = [];\n        for (const p of path) {\n            let sp = '';\n            if (typeof p === 'number') {\n                sp = p.toString();\n            } else {\n                sp = p;\n            }\n\n            const match = Reb64.exec(sp);\n            if (!match) {\n                throw new Error(`\"Non Base64 path component = ${p}.`);\n            }\n\n            vath.push(sp);\n        }\n        return '-' + vath.join('-');\n    }\n}\n", "import { SignifyClient } from './clienting';\nimport { b, d, Dict, Ident, Ilks, Serials, versify } from '../core/core';\nimport { Serder } from '../core/serder';\nimport { nowUTC } from '../core/utils';\nimport { Pather } from '../core/pather';\nimport { Counter, CtrDex } from '../core/counter';\nimport { Saider } from '../core/saider';\nimport { HabState } from '../core/state';\n\n/**\n * Exchanges\n */\nexport class Exchanges {\n    client: SignifyClient;\n\n    /**\n     * Exchanges\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Create exn message\n     * @async\n     * @returns {Promise<any>} A promise to the list of replay messages\n     * @param sender\n     * @param route\n     * @param payload\n     * @param embeds\n     * @param recipient\n     * @param datetime\n     * @param dig\n     */\n    async createExchangeMessage(\n        sender: HabState,\n        route: string,\n        payload: Dict<any>,\n        embeds: Dict<any>,\n        recipient: string,\n        datetime?: string,\n        dig?: string\n    ): Promise<[Serder, string[], string]> {\n        const keeper = this.client.manager!.get(sender);\n        const [exn, end] = exchange(\n            route,\n            payload,\n            sender['prefix'],\n            recipient,\n            datetime,\n            dig,\n            undefined,\n            embeds\n        );\n\n        const sigs = await keeper.sign(b(exn.raw));\n        return [exn, sigs, d(end)];\n    }\n\n    /**\n     * Send exn messages to list of recipients\n     * @async\n     * @returns {Promise<any>} A promise to the list of replay messages\n     * @param name\n     * @param topic\n     * @param sender\n     * @param route\n     * @param payload\n     * @param embeds\n     * @param recipients\n     */\n    async send(\n        name: string,\n        topic: string,\n        sender: HabState,\n        route: string,\n        payload: Dict<any>,\n        embeds: Dict<any>,\n        recipients: string[]\n    ): Promise<any> {\n        for (const recipient of recipients) {\n            const [exn, sigs, atc] = await this.createExchangeMessage(\n                sender,\n                route,\n                payload,\n                embeds,\n                recipient\n            );\n            return await this.sendFromEvents(\n                name,\n                topic,\n                exn,\n                sigs,\n                atc,\n                recipients\n            );\n        }\n    }\n\n    /**\n     * Send exn messaget to list of recipients\n     * @async\n     * @returns {Promise<any>} A promise to the list of replay messages\n     * @param name\n     * @param topic\n     * @param exn\n     * @param sigs\n     * @param atc\n     * @param recipients\n     */\n    async sendFromEvents(\n        name: string,\n        topic: string,\n        exn: Serder,\n        sigs: string[],\n        atc: string,\n        recipients: string[]\n    ): Promise<any> {\n        const path = `/identifiers/${name}/exchanges`;\n        const method = 'POST';\n        const data: any = {\n            tpc: topic,\n            exn: exn.ked,\n            sigs: sigs,\n            atc: atc,\n            rec: recipients,\n        };\n\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n\n    /**\n     * Get exn message by said\n     * @async\n     * @returns A promise to the exn message\n     * @param said The said of the exn message\n     */\n    async get(said: string): Promise<any> {\n        const path = `/exchanges/${said}`;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n}\n\nexport function exchange(\n    route: string,\n    payload: Dict<any>,\n    sender: string,\n    recipient: string,\n    date?: string,\n    dig?: string,\n    modifiers?: Dict<any>,\n    embeds?: Dict<any>\n): [Serder, Uint8Array] {\n    const vs = versify(Ident.KERI, undefined, Serials.JSON, 0);\n    const ilk = Ilks.exn;\n    const dt =\n        date !== undefined\n            ? date\n            : nowUTC().toISOString().replace('Z', '000+00:00');\n    const p = dig !== undefined ? dig : '';\n    const q = modifiers !== undefined ? modifiers : {};\n    const ems = embeds != undefined ? embeds : {};\n\n    let e = {} as Dict<any>;\n    let end = '';\n    Object.entries(ems).forEach(([key, value]) => {\n        const serder = value[0];\n        const atc = value[1];\n        e[key] = serder.ked;\n\n        if (atc == undefined) {\n            return;\n        }\n        let pathed = '';\n        const pather = new Pather({}, undefined, ['e', key]);\n        pathed += pather.qb64;\n        pathed += atc;\n\n        const counter = new Counter({\n            code: CtrDex.PathedMaterialQuadlets,\n            count: Math.floor(pathed.length / 4),\n        });\n        end += counter.qb64;\n        end += pathed;\n    });\n\n    if (Object.keys(e).length > 0) {\n        e['d'] = '';\n        [, e] = Saider.saidify(e);\n    }\n\n    const attrs = {} as Dict<any>;\n\n    attrs['i'] = recipient;\n\n    const a = {\n        ...attrs,\n        ...payload,\n    };\n\n    const _ked = {\n        v: vs,\n        t: ilk,\n        d: '',\n        i: sender,\n        rp: recipient,\n        p: p,\n        dt: dt,\n        r: route,\n        q: q,\n        a: a,\n        e: e,\n    };\n    const [, ked] = Saider.saidify(_ked);\n\n    const exn = new Serder(ked);\n\n    return [exn, b(end)];\n}\n", "import { SignifyClient } from './clienting';\nimport { Dict } from '../core/core';\n\n/**\n * Groups\n */\nexport class Groups {\n    client: SignifyClient;\n\n    /**\n     * Groups\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * Get group request messages\n     * @async\n     * @param {string} [said] SAID of exn message to load\n     * @returns {Promise<any>} A promise to the list of replay messages\n     */\n    async getRequest(said: string): Promise<any> {\n        const path = `/multisig/request/` + said;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null);\n        return await res.json();\n    }\n\n    /**\n     * Send multisig exn request  messages to other group members\n     * @async\n     * @param {string} [name] human readable name of group AID\n     * @param {Dict<any>} [exn] exn message to send to other members\n     * @param {string[]} [sigs] signature of the participant over the exn\n     * @param {string} [atc] additional attachments from embedded events in exn\n     * @returns {Promise<any>} A promise to the list of replay messages\n     */\n    async sendRequest(\n        name: string,\n        exn: Dict<any>,\n        sigs: string[],\n        atc: string\n    ): Promise<any> {\n        const path = `/identifiers/${name}/multisig/request`;\n        const method = 'POST';\n        const data = {\n            exn: exn,\n            sigs: sigs,\n            atc: atc,\n        };\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n\n    /**\n     * Join multisig group using rotation event.\n     * This can be used by participants being asked to contribute keys to a rotation event to join an existing group.\n     * @async\n     * @param {string} [name] human readable name of group AID\n     * @param {any} [rot] rotation event\n     * @param {any} [sigs] signatures\n     * @param {string} [gid] prefix\n     * @param {string[]} [smids] array of particpants\n     * @param {string[]} [rmids] array of particpants\n     * @returns {Promise<any>} A promise to the list of replay messages\n     */\n    async join(\n        name: string,\n        rot: any,\n        sigs: any, //string[],\n        gid: string,\n        smids: string[],\n        rmids: string[]\n    ): Promise<any> {\n        const path = `/identifiers/${name}/multisig/join`;\n        const method = 'POST';\n        const data = {\n            tpc: 'multisig',\n            rot: rot.ked,\n            sigs: sigs,\n            gid: gid,\n            smids: smids,\n            rmids: rmids,\n        };\n        const res = await this.client.fetch(path, method, data);\n        return await res.json();\n    }\n}\n", "import { SignifyClient } from './clienting';\nimport { parseRangeHeaders } from '../core/httping';\n\n/**\n * Notifications\n */\nexport class Notifications {\n    client: SignifyClient;\n\n    /**\n     * Notifications\n     * @param {SignifyClient} client\n     */\n    constructor(client: SignifyClient) {\n        this.client = client;\n    }\n\n    /**\n     * List notifications\n     * @async\n     * @param {number} [start=0] Start index of list of notifications, defaults to 0\n     * @param {number} [end=24] End index of list of notifications, defaults to 24\n     * @returns {Promise<any>} A promise to the list of notifications\n     */\n    async list(start: number = 0, end: number = 24): Promise<any> {\n        const extraHeaders = new Headers();\n        extraHeaders.append('Range', `notes=${start}-${end}`);\n\n        const path = `/notifications`;\n        const method = 'GET';\n        const res = await this.client.fetch(path, method, null, extraHeaders);\n\n        const cr = res.headers.get('content-range');\n        const range = parseRangeHeaders(cr, 'notes');\n        const notes = await res.json();\n\n        return {\n            start: range.start,\n            end: range.end,\n            total: range.total,\n            notes: notes,\n        };\n    }\n\n    /**\n     * Mark a notification as read\n     * @async\n     * @param {string} said SAID of the notification\n     * @returns {Promise<string>} A promise to the result of the marking\n     */\n    async mark(said: string): Promise<string> {\n        const path = `/notifications/` + said;\n        const method = 'PUT';\n        const res = await this.client.fetch(path, method, null);\n        return await res.text();\n    }\n\n    /**\n     * Delete a notification\n     * @async\n     * @param {string} said SAID of the notification\n     * @returns {Promise<any>} A promise to the result of the deletion\n     */\n    async delete(said: string): Promise<void> {\n        const path = `/notifications/` + said;\n        const method = 'DELETE';\n        await this.client.fetch(path, method, null);\n    }\n}\n", "import { Authenticater } from '../core/authing';\nimport { HEADER_SIG_TIME } from '../core/httping';\nimport { ExternalModule, KeyManager } from '../core/keeping';\nimport { Tier } from '../core/salter';\n\nimport { Identifier } from './aiding';\nimport { Contacts, Challenges } from './contacting';\nimport { Agent, Controller } from './controller';\nimport { Oobis, Operations, KeyEvents, KeyStates } from './coring';\nimport { Credentials, Ipex, Registries, Schemas } from './credentialing';\nimport { Delegations } from './delegating';\nimport { Escrows } from './escrowing';\nimport { Exchanges } from './exchanging';\nimport { Groups } from './grouping';\nimport { Notifications } from './notifying';\n\nconst DEFAULT_BOOT_URL = 'http://localhost:3903';\n\nclass State {\n    agent: any | null;\n    controller: any | null;\n    ridx: number;\n    pidx: number;\n\n    constructor() {\n        this.agent = null;\n        this.controller = null;\n        this.pidx = 0;\n        this.ridx = 0;\n    }\n}\n\n/** SignifyClient */\nexport class SignifyClient {\n    public controller: Controller;\n    public url: string;\n    public bran: string;\n    public pidx: number;\n    public agent: Agent | null;\n    public authn: Authenticater | null;\n    public manager: KeyManager | null;\n    public tier: Tier;\n    public bootUrl: string;\n    public exteralModules: ExternalModule[];\n\n    /**\n     * SignifyClient constructor\n     * @param {string} url KERIA admin interface URL\n     * @param {string} bran Base64 21 char string that is used as base material for seed of the client AID\n     * @param {Tier} tier Security tier for generating keys of the client AID (high | mewdium | low)\n     * @param {string} bootUrl KERIA boot interface URL\n     * @param {ExternalModule[]} externalModules list of external modules to load\n     */\n    constructor(\n        url: string,\n        bran: string,\n        tier: Tier = Tier.low,\n        bootUrl: string = DEFAULT_BOOT_URL,\n        externalModules: ExternalModule[] = []\n    ) {\n        this.url = url;\n        if (bran.length < 21) {\n            throw Error('bran must be 21 characters');\n        }\n        this.bran = bran;\n        this.pidx = 0;\n        this.controller = new Controller(bran, tier);\n        this.authn = null;\n        this.agent = null;\n        this.manager = null;\n        this.tier = tier;\n        this.bootUrl = bootUrl;\n        this.exteralModules = externalModules;\n    }\n\n    get data() {\n        return [this.url, this.bran, this.pidx, this.authn];\n    }\n\n    /**\n     * Boot a KERIA agent\n     * @async\n     * @returns {Promise<Response>} A promise to the result of the boot\n     */\n    async boot(): Promise<Response> {\n        const [evt, sign] = this.controller?.event ?? [];\n        const data = {\n            icp: evt.ked,\n            sig: sign.qb64,\n            stem: this.controller?.stem,\n            pidx: 1,\n            tier: this.controller?.tier,\n        };\n\n        return await fetch(this.bootUrl + '/boot', {\n            method: 'POST',\n            body: JSON.stringify(data),\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        });\n    }\n\n    /**\n     * Get state of the agent and the client\n     * @async\n     * @returns {Promise<Response>} A promise to the state\n     */\n    async state(): Promise<State> {\n        const caid = this.controller?.pre;\n\n        const res = await fetch(this.url + `/agent/${caid}`);\n        if (res.status == 404) {\n            throw new Error(`agent does not exist for controller ${caid}`);\n        }\n\n        const data = await res.json();\n        const state = new State();\n        state.agent = data.agent ?? {};\n        state.controller = data.controller ?? {};\n        state.ridx = data.ridx ?? 0;\n        state.pidx = data.pidx ?? 0;\n        return state;\n    }\n\n    /**  Connect to a KERIA agent\n     * @async\n     */\n    async connect() {\n        const state = await this.state();\n        this.pidx = state.pidx;\n        //Create controller representing the local client AID\n        this.controller = new Controller(\n            this.bran,\n            this.tier,\n            0,\n            state.controller\n        );\n        this.controller.ridx = state.ridx !== undefined ? state.ridx : 0;\n        // Create agent representing the AID of KERIA cloud agent\n        this.agent = new Agent(state.agent);\n        if (this.agent.anchor != this.controller.pre) {\n            throw Error(\n                'commitment to controller AID missing in agent inception event'\n            );\n        }\n        if (this.controller.serder.ked.s == 0) {\n            await this.approveDelegation();\n        }\n        this.manager = new KeyManager(\n            this.controller.salter,\n            this.exteralModules\n        );\n        this.authn = new Authenticater(\n            this.controller.signer,\n            this.agent.verfer!\n        );\n    }\n\n    /**\n     * Fetch a resource from the KERIA agent\n     * @async\n     * @param {string} path Path to the resource\n     * @param {string} method HTTP method\n     * @param {any} data Data to be sent in the body of the resource\n     * @param {Headers} [extraHeaders] Optional extra headers to be sent with the request\n     * @returns {Promise<Response>} A promise to the result of the fetch\n     */\n    async fetch(\n        path: string,\n        method: string,\n        data: any,\n        extraHeaders?: Headers\n    ): Promise<Response> {\n        const headers = new Headers();\n        let signed_headers = new Headers();\n        const final_headers = new Headers();\n\n        headers.set('Signify-Resource', this.controller.pre);\n        headers.set(\n            HEADER_SIG_TIME,\n            new Date().toISOString().replace('Z', '000+00:00')\n        );\n        headers.set('Content-Type', 'application/json');\n\n        const _body = method == 'GET' ? null : JSON.stringify(data);\n\n        if (this.authn) {\n            signed_headers = this.authn.sign(\n                headers,\n                method,\n                path.split('?')[0]\n            );\n        } else {\n            throw new Error('client need to call connect first');\n        }\n\n        signed_headers.forEach((value, key) => {\n            final_headers.set(key, value);\n        });\n        if (extraHeaders !== undefined) {\n            extraHeaders.forEach((value, key) => {\n                final_headers.append(key, value);\n            });\n        }\n        const res = await fetch(this.url + path, {\n            method: method,\n            body: _body,\n            headers: final_headers,\n        });\n        if (!res.ok) {\n            const error = await res.text();\n            const message = `HTTP ${method} ${path} - ${res.status} ${res.statusText} - ${error}`;\n            throw new Error(message);\n        }\n        const isSameAgent =\n            this.agent?.pre === res.headers.get('signify-resource');\n        if (!isSameAgent) {\n            throw new Error('message from a different remote agent');\n        }\n\n        const verification = this.authn.verify(\n            res.headers,\n            method,\n            path.split('?')[0]\n        );\n        if (verification) {\n            return res;\n        } else {\n            throw new Error('response verification failed');\n        }\n    }\n\n    /**\n     * Create a Signed Request to fetch a resource from an external URL with headers signed by an AID\n     * @async\n     * @param {string} aidName Name or alias of the AID to be used for signing\n     * @param {string} url URL of the requested resource\n     * @param {RequestInit} req Request options should include:\n     *     - method: HTTP method\n     *     - data Data to be sent in the body of the resource.\n     *              If the data is a CESR JSON string then you should also set contentType to 'application/json+cesr'\n     *              If the data is a FormData object then you should not set the contentType and the browser will set it to 'multipart/form-data'\n     *              If the data is an object then you should use JSON.stringify to convert it to a string and set the contentType to 'application/json'\n     *     - contentType Content type of the request.\n     * @returns {Promise<Request>} A promise to the created Request\n     */\n    async createSignedRequest(\n        aidName: string,\n        url: string,\n        req: RequestInit\n    ): Promise<Request> {\n        const hab = await this.identifiers().get(aidName);\n        const keeper = this.manager!.get(hab);\n\n        const authenticator = new Authenticater(\n            keeper.signers[0],\n            keeper.signers[0].verfer\n        );\n\n        const headers = new Headers(req.headers);\n        headers.set('Signify-Resource', hab['prefix']);\n        headers.set(\n            HEADER_SIG_TIME,\n            new Date().toISOString().replace('Z', '000+00:00')\n        );\n\n        const signed_headers = authenticator.sign(\n            new Headers(headers),\n            req.method ?? 'GET',\n            new URL(url).pathname\n        );\n        req.headers = signed_headers;\n\n        return new Request(url, req);\n    }\n\n    /**\n     * Approve the delegation of the client AID to the KERIA agent\n     * @async\n     * @returns {Promise<Response>} A promise to the result of the approval\n     */\n    async approveDelegation(): Promise<Response> {\n        const sigs = this.controller.approveDelegation(this.agent!);\n\n        const data = {\n            ixn: this.controller.serder.ked,\n            sigs: sigs,\n        };\n\n        return await fetch(\n            this.url + '/agent/' + this.controller.pre + '?type=ixn',\n            {\n                method: 'PUT',\n                body: JSON.stringify(data),\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            }\n        );\n    }\n\n    /**\n     * Save old client passcode in KERIA agent\n     * @async\n     * @param {string} passcode Passcode to be saved\n     * @returns {Promise<Response>} A promise to the result of the save\n     */\n    async saveOldPasscode(passcode: string): Promise<Response> {\n        const caid = this.controller?.pre;\n        const body = { salt: passcode };\n        return await fetch(this.url + '/salt/' + caid, {\n            method: 'PUT',\n            body: JSON.stringify(body),\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        });\n    }\n\n    /**\n     * Delete a saved passcode from KERIA agent\n     * @async\n     * @returns {Promise<Response>} A promise to the result of the deletion\n     */\n    async deletePasscode(): Promise<Response> {\n        const caid = this.controller?.pre;\n        return await fetch(this.url + '/salt/' + caid, {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        });\n    }\n\n    /**\n     * Rotate the client AID\n     * @async\n     * @param {string} nbran Base64 21 char string that is used as base material for the new seed\n     * @param {Array<string>} aids List of managed AIDs to be rotated\n     * @returns {Promise<Response>} A promise to the result of the rotation\n     */\n    async rotate(nbran: string, aids: string[]): Promise<Response> {\n        const data = this.controller.rotate(nbran, aids);\n        return await fetch(this.url + '/agent/' + this.controller.pre, {\n            method: 'PUT',\n            body: JSON.stringify(data),\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        });\n    }\n\n    /**\n     * Get identifiers resource\n     * @returns {Identifier}\n     */\n    identifiers(): Identifier {\n        return new Identifier(this);\n    }\n\n    /**\n     * Get OOBIs resource\n     * @returns {Oobis}\n     */\n    oobis(): Oobis {\n        return new Oobis(this);\n    }\n\n    /**\n     * Get operations resource\n     * @returns {Operations}\n     */\n    operations(): Operations {\n        return new Operations(this);\n    }\n\n    /**\n     * Get keyEvents resource\n     * @returns {KeyEvents}\n     */\n    keyEvents(): KeyEvents {\n        return new KeyEvents(this);\n    }\n\n    /**\n     * Get keyStates resource\n     * @returns {KeyStates}\n     */\n    keyStates(): KeyStates {\n        return new KeyStates(this);\n    }\n\n    /**\n     * Get credentials resource\n     * @returns {Credentials}\n     */\n    credentials(): Credentials {\n        return new Credentials(this);\n    }\n\n    /**\n     * Get IPEX resource\n     * @returns {Ipex}\n     */\n    ipex(): Ipex {\n        return new Ipex(this);\n    }\n\n    /**\n     * Get registries resource\n     * @returns {Registries}\n     */\n    registries(): Registries {\n        return new Registries(this);\n    }\n\n    /**\n     * Get schemas resource\n     * @returns {Schemas}\n     */\n    schemas(): Schemas {\n        return new Schemas(this);\n    }\n\n    /**\n     * Get challenges resource\n     * @returns {Challenges}\n     */\n    challenges(): Challenges {\n        return new Challenges(this);\n    }\n\n    /**\n     * Get contacts resource\n     * @returns {Contacts}\n     */\n    contacts(): Contacts {\n        return new Contacts(this);\n    }\n\n    /**\n     * Get notifications resource\n     * @returns {Notifications}\n     */\n    notifications(): Notifications {\n        return new Notifications(this);\n    }\n\n    /**\n     * Get escrows resource\n     * @returns {Escrows}\n     */\n    escrows(): Escrows {\n        return new Escrows(this);\n    }\n\n    /**\n     * Get groups resource\n     * @returns {Groups}\n     */\n    groups(): Groups {\n        return new Groups(this);\n    }\n\n    /**\n     * Get exchange resource\n     * @returns {Exchanges}\n     */\n    exchanges(): Exchanges {\n        return new Exchanges(this);\n    }\n\n    /**\n     * Get delegations resource\n     * @returns {Delegations}\n     */\n    delegations(): Delegations {\n        return new Delegations(this);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;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",
  "names": ["_sodium", "import_libsodium_wrappers_sumo", "Serials", "Ident", "i", "import_buffer", "qb64", "import_libsodium_wrappers_sumo", "libsodium", "secp256r1", "import_libsodium_wrappers_sumo", "import_buffer", "qb64", "import_buffer", "raw", "libsodium", "import_libsodium_wrappers_sumo", "import_libsodium_wrappers_sumo", "Tier", "libsodium", "libsodium", "qb64", "x", "import_buffer", "import_buffer", "import_blake3", "import_buffer", "import_blake3", "Dummy", "Ids", "libsodium", "Algos", "code", "seed", "mask", "signer", "import_buffer", "value", "siginput", "range", "state", "tag", "val", "siginput", "signature", "import_libsodium_wrappers_sumo", "libsodium", "vdr", "incept", "state", "import_buffer", "range"]
}
